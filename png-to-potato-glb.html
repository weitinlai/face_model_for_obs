<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <title>PNG → potato.glb</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, sans-serif; margin: 0; padding: 16px; }
    .bar { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    canvas { width: 100%; max-width: 640px; height: 360px; background: #111; border-radius: 12px; display: block; margin-top: 12px; }
    small { color: #666; }
  </style>
</head>
<body>
  <h1>用 PNG 生成 potato.glb</h1>
  <div class="bar">
    <input id="file" type="file" accept="image/png,image/jpeg" />
    <label>UV 重複：U <input id="repU" type="number" min="1" step="1" value="1" style="width:64px"></label>
    <label>V <input id="repV" type="number" min="1" step="1" value="1" style="width:64px"></label>
    <label>分段：W <input id="segW" type="number" min="8" step="1" value="48" style="width:64px"></label>
    <label>H <input id="segH" type="number" min="6" step="1" value="32" style="width:64px"></label>
    <label>形狀：X <input id="scaleX" type="number" step="0.05" value="0.9" style="width:64px"></label>
    <label>Y <input id="scaleY" type="number" step="0.05" value="1.2" style="width:64px"></label>
    <label>Z <input id="scaleZ" type="number" step="0.05" value="0.9" style="width:64px"></label>
    <button id="exportBtn" disabled>匯出 GLB</button>
  </div>
  <div id="status" style="margin-top: 8px; font-size: 12px; color: #666; text-align: center;"></div>
  <small>提示：用 scale 把球拉成馬鈴薯；repU/repV 可重複貼圖；segW/segH 提高可以更平滑（檔案也會變大）。</small>
  <canvas id="view"></canvas>

  <script type="module">
    // 嘗試多個CDN路徑
    const THREE_URLS = [
      'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.module.js',
      'https://unpkg.com/three@0.158.0/build/three.module.js',
      'https://esm.sh/three@0.158.0'
    ];

    const GLTF_EXPORTER_URLS = [
      'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/examples/jsm/exporters/GLTFExporter.js',
      'https://unpkg.com/three@0.158.0/examples/jsm/exporters/GLTFExporter.js',
      'https://esm.sh/three@0.158.0/examples/jsm/exporters/GLTFExporter.js'
    ];

    let THREE, GLTFExporter;
    let scene, camera, renderer, mesh, texture;

    function updateStatus(message, type = 'info') {
      const statusEl = document.getElementById('status');
      if (statusEl) {
        statusEl.textContent = message;
        statusEl.style.color = type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : type === 'warning' ? '#ff9800' : '#666';
      }
    }

    // 載入模組
    async function loadModules() {
      updateStatus('正在載入Three.js...', 'info');
      
      try {
        // 載入Three.js
        for (const url of THREE_URLS) {
          try {
            THREE = await import(url);
            console.log('Three.js loaded from:', url);
            updateStatus('Three.js載入成功，正在載入GLTFExporter...', 'success');
            break;
          } catch (e) {
            console.warn('Failed to load Three.js from:', url, e);
          }
        }

        if (!THREE) {
          throw new Error('Failed to load Three.js from all sources');
        }

        // 載入GLTFExporter
        for (const url of GLTF_EXPORTER_URLS) {
          try {
            const module = await import(url);
            GLTFExporter = module.GLTFExporter;
            console.log('GLTFExporter loaded from:', url);
            updateStatus('GLTFExporter載入成功，正在初始化場景...', 'success');
            break;
          } catch (e) {
            console.warn('Failed to load GLTFExporter from:', url, e);
          }
        }

        if (!GLTFExporter) {
          throw new Error('Failed to load GLTFExporter from all sources');
        }

        // 初始化場景
        initScene();
        animate();
        updateStatus('所有模組載入成功！可以開始使用了', 'success');
        console.log('All modules loaded successfully');
      } catch (error) {
        console.error('Module loading failed:', error);
        updateStatus('模組載入失敗: ' + error.message, 'error');
        alert('模組載入失敗: ' + error.message + '\n請檢查網路連接或刷新頁面重試');
      }
    }

    function initScene() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 3;

      renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('view'), antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5,5,5);
      scene.add(light);

      const geometry = new THREE.SphereGeometry(1, 48, 32);
      const material = new THREE.MeshStandardMaterial({ color: 0xcccc99 });
      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      document.getElementById("exportBtn").disabled = false;

      // 綁定事件
      document.getElementById("file").addEventListener("change", loadTexture);
      document.getElementById("repU").addEventListener("input", updateTextureRepeat);
      document.getElementById("repV").addEventListener("input", updateTextureRepeat);
      document.getElementById("segW").addEventListener("input", updateGeometry);
      document.getElementById("segH").addEventListener("input", updateGeometry);
      document.getElementById("scaleX").addEventListener("input", updateScale);
      document.getElementById("scaleY").addEventListener("input", updateScale);
      document.getElementById("scaleZ").addEventListener("input", updateScale);
      document.getElementById("exportBtn").addEventListener("click", exportGLB);
    }

    function animate(){
      requestAnimationFrame(animate);
      if (mesh) {
        mesh.rotation.y += 0.01;
        renderer.render(scene, camera);
      }
    }

    function loadTexture(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      console.log('Loading texture:', file.name, 'size:', file.size);
      
      const url = URL.createObjectURL(file);
      new THREE.TextureLoader().load(url, (tex) => {
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        texture = tex;
        mesh.material.map = texture;
        mesh.material.needsUpdate = true;
        updateTextureRepeat();
        console.log('Texture loaded successfully');
      }, undefined, (error) => {
        console.error('Texture loading failed:', error);
        alert('貼圖載入失敗: ' + error.message);
      });
    }

    function updateTextureRepeat() {
      if (!texture) return;
      const repU = parseInt(document.getElementById("repU").value) || 1;
      const repV = parseInt(document.getElementById("repV").value) || 1;
      texture.repeat.set(repU, repV);
      texture.needsUpdate = true;
    }

    function updateGeometry() {
      const segW = parseInt(document.getElementById("segW").value) || 48;
      const segH = parseInt(document.getElementById("segH").value) || 32;
      const newGeo = new THREE.SphereGeometry(1, segW, segH);
      mesh.geometry.dispose();
      mesh.geometry = newGeo;
    }

    function updateScale() {
      mesh.scale.set(
        parseFloat(document.getElementById("scaleX").value) || 1,
        parseFloat(document.getElementById("scaleY").value) || 1,
        parseFloat(document.getElementById("scaleZ").value) || 1
      );
    }

    function exportGLB() {
      if (!GLTFExporter) {
        updateStatus('GLTFExporter未載入，無法匯出', 'error');
        alert('GLTFExporter未載入，無法匯出');
        return;
      }

      updateStatus('正在匯出GLB...', 'info');
      console.log('Starting GLB export...');
      console.log('Scene objects:', scene.children.length);
      console.log('Mesh geometry:', mesh.geometry);
      console.log('Mesh material:', mesh.material);

      try {
        const exporter = new GLTFExporter();
        exporter.parse(scene, (result) => {
          console.log('Export successful, result size:', result.byteLength);
          
          const blob = new Blob([result], { type: "application/octet-stream" });
          console.log('Blob created, size:', blob.size);
          
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "potato.glb";
          a.click();
          
          URL.revokeObjectURL(url);
          console.log('GLB file downloaded successfully');
          updateStatus('GLB匯出成功！文件大小: ' + (blob.size / 1024).toFixed(2) + ' KB', 'success');
          alert('GLB匯出成功！文件大小: ' + (blob.size / 1024).toFixed(2) + ' KB');
        }, (error) => {
          console.error('Export failed:', error);
          updateStatus('匯出失敗: ' + error.message, 'error');
          alert('匯出失敗: ' + error.message);
        }, { binary: true });
      } catch (error) {
        console.error('Export error:', error);
        updateStatus('匯出錯誤: ' + error.message, 'error');
        alert('匯出錯誤: ' + error.message);
      }
    }

    // 開始載入模組
    loadModules();
  </script>
</body>
</html>

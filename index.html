<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Face Mesh for OBS</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <!-- Three.js 和 GLTFLoader 使用 ES6 模組載入 -->
    <script type="module">
        // 嘗試多個CDN路徑載入Three.js和GLTFLoader
        const THREE_URLS = [
            'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.module.js',
            'https://unpkg.com/three@0.158.0/build/three.module.js',
            'https://esm.sh/three@0.158.0'
        ];

        const GLTF_LOADER_URLS = [
            'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/examples/jsm/loaders/GLTFLoader.js',
            'https://unpkg.com/three@0.158.0/examples/jsm/loaders/GLTFLoader.js',
            'https://esm.sh/three@0.158.0/examples/jsm/loaders/GLTFLoader.js'
        ];

        let THREE, GLTFLoader;

        // 載入模組
        async function loadModules() {
            try {
                // 載入Three.js
                for (const url of THREE_URLS) {
                    try {
                        THREE = await import(url);
                        console.log('Three.js loaded from:', url);
                        break;
                    } catch (e) {
                        console.warn('Failed to load Three.js from:', url, e);
                    }
                }

                if (!THREE) {
                    throw new Error('Failed to load Three.js from all sources');
                }

                // 載入GLTFLoader
                for (const url of GLTF_LOADER_URLS) {
                    try {
                        const module = await import(url);
                        GLTFLoader = module.GLTFLoader;
                        console.log('GLTFLoader loaded from:', url);
                        break;
                    } catch (e) {
                        console.warn('Failed to load GLTFLoader from:', url, e);
                    }
                }

                if (!GLTFLoader) {
                    throw new Error('Failed to load GLTFLoader from all sources');
                }

                // 將THREE和GLTFLoader暴露到全局
                window.THREE = THREE;
                window.GLTFLoader = GLTFLoader;
                
                console.log('All modules loaded successfully');
                
                // 觸發載入完成事件
                window.dispatchEvent(new CustomEvent('modulesLoaded'));
                
            } catch (error) {
                console.error('Module loading failed:', error);
                alert('模組載入失敗: ' + error.message + '\n請檢查網路連接或刷新頁面重試');
            }
        }

        // 開始載入模組
        loadModules();
    </script>

    <!-- 等待模組載入完成後初始化 -->
    <script>
        // 監聽模組載入完成事件
        window.addEventListener('modulesLoaded', () => {
            console.log('模組載入完成，檢查MediaPipe狀態...');
            if (isMediaPipeLoaded) {
                initFaceMesh();
            }
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            overflow: hidden;
            color: white;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #videoElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            opacity: 0.3;
        }

        #threeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 10;
            min-width: 250px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #fff;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group input[type="checkbox"] {
            margin-right: 8px;
        }

        .value-display {
            font-size: 12px;
            color: #ccc;
            text-align: center;
        }

        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-connected {
            background-color: #4CAF50;
        }

        .status-disconnected {
            background-color: #f44336;
        }

        #fps {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 10;
            font-family: monospace;
        }

        .button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 5px 0;
            width: 100%;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="videoElement" autoplay muted></video>
        <canvas id="threeCanvas"></canvas>
        
        <div id="status">
            <span class="status-indicator status-disconnected" id="statusIndicator"></span>
            <span id="statusText">未連接</span>
        </div>

        <div id="controls">
            <h3 style="margin-bottom: 20px; text-align: center;">3D Face Mesh 控制</h3>
            
            <div class="control-group">
                <label>網格透明度: <span id="opacityValue">0.8</span></label>
                <input type="range" id="opacitySlider" min="0" max="1" step="0.1" value="0.8">
            </div>

            <div class="control-group">
                <label>網格顏色</label>
                <input type="color" id="meshColor" value="#00ff88">
            </div>

            <div class="control-group">
                <label>網格深度: <span id="depthValue">5</span></label>
                <input type="range" id="depthSlider" min="1" max="10" step="0.5" value="5">
            </div>

            <div class="control-group">
                <label>網格大小: <span id="scaleValue">10</span></label>
                <input type="range" id="scaleSlider" min="5" max="20" step="0.5" value="10">
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showWireframe" checked> 顯示線框
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showPoints" checked> 顯示點
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="smoothTracking" checked> 平滑追蹤
                </label>
            </div>

            <div class="control-group">
                <label>3D模型濾鏡</label>
                <input type="file" id="glbFile" accept=".glb,.gltf" style="width: 100%; margin-bottom: 10px;">
                <button class="button" id="loadGLB">載入3D模型</button>
                <button class="button" id="removeGLB" style="background: #f44336;">移除模型</button>
                <button class="button" id="testLoader" style="background: #ff9800; margin-top: 5px;">測試載入器</button>
                <div id="modelStatus" style="font-size: 12px; color: #ccc; margin-top: 5px; text-align: center;"></div>
            </div>

            <div class="control-group">
                <label>模型縮放: <span id="modelScaleValue">1.0</span></label>
                <input type="range" id="modelScaleSlider" min="0.1" max="3" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>模型旋轉Y: <span id="modelRotationValue">0</span>°</label>
                <input type="range" id="modelRotationSlider" min="0" max="360" step="1" value="0">
            </div>

            <div class="control-group">
                <label>表情反應強度: <span id="expressionValue">0.5</span></label>
                <input type="range" id="expressionSlider" min="0" max="1" step="0.1" value="0.5">
            </div>

            <div class="control-group">
                <label>臉部追蹤靈敏度: <span id="trackingValue">1.0</span></label>
                <input type="range" id="trackingSlider" min="0.1" max="2.0" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>面具貼合強度: <span id="maskFitValue">1.0</span></label>
                <input type="range" id="maskFitSlider" min="0.5" max="2.0" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>深度貼合: <span id="depthFitValue">1.0</span></label>
                <input type="range" id="depthFitSlider" min="0.1" max="2.0" step="0.1" value="1.0">
            </div>

            <button class="button" id="resetCamera">重置相機</button>
            <button class="button" id="fullscreen">全螢幕</button>
        </div>

        <div id="fps">
            FPS: <span id="fpsValue">0</span>
        </div>
    </div>

    <script>
        // 等待MediaPipe載入
        let FaceMesh = null;
        let Camera = null;
        let isMediaPipeLoaded = false;

        // 檢查MediaPipe是否可用
        function checkMediaPipe() {
            if (typeof window.FaceMesh !== 'undefined' && typeof window.Camera !== 'undefined') {
                FaceMesh = window.FaceMesh;
                Camera = window.Camera;
                isMediaPipeLoaded = true;
                console.log('MediaPipe Face Mesh 和 Camera 已載入');
                initFaceMesh();
            } else {
                console.log('等待 MediaPipe 載入...');
                setTimeout(checkMediaPipe, 100);
            }
        }

        // 添加重試機制
        let retryCount = 0;
        const maxRetries = 20;
        
        function checkMediaPipeWithRetry() {
            if (retryCount >= maxRetries) {
                console.error('MediaPipe 載入失敗，請檢查網路連接');
                document.getElementById('statusText').textContent = 'MediaPipe 載入失敗';
                return;
            }
            
            if (typeof window.FaceMesh !== 'undefined' && typeof window.Camera !== 'undefined') {
                FaceMesh = window.FaceMesh;
                Camera = window.Camera;
                isMediaPipeLoaded = true;
                console.log('MediaPipe Face Mesh 和 Camera 已載入');
                initFaceMesh();
            } else {
                retryCount++;
                console.log(`等待 MediaPipe 載入... (嘗試 ${retryCount}/${maxRetries})`);
                setTimeout(checkMediaPipeWithRetry, 500);
            }
        }

        // 初始化函數
        function initFaceMesh() {
            if (isMediaPipeLoaded && window.THREE && window.GLTFLoader) {
                console.log('所有模組已載入，開始初始化...');
                new FaceMeshTracker();
            } else {
                console.log('等待模組載入... MediaPipe:', isMediaPipeLoaded, 'THREE:', !!window.THREE, 'GLTFLoader:', !!window.GLTFLoader);
                setTimeout(initFaceMesh, 100);
            }
        }

        class FaceMeshTracker {
            constructor() {
                this.faceMesh = null;
                this.camera = null;
                this.videoElement = null;
                this.threeCanvas = null;
                this.threeScene = null;
                this.threeCamera = null;
                this.threeRenderer = null;
                this.faceMesh3D = null;
                this.facePoints = null;
                this.landmarks = [];
                this.isTracking = false;
                this.fpsCounter = 0;
                this.lastTime = 0;
                
                this.settings = {
                    opacity: 0.8,
                    meshColor: '#00ff88',
                    depth: 5,
                    scale: 10,
                    showWireframe: true,
                    showPoints: true,
                    smoothTracking: true,
                    modelScale: 1.0,
                    modelRotationY: 0,
                    expressionIntensity: 0.5,
                    trackingSensitivity: 1.0,
                    maskFitStrength: 1.0,
                    depthFitStrength: 1.0
                };
                
                this.init();
            }

            async init() {
                try {
                    await this.setupMediaPipe();
                    this.setupThreeJS();
                    this.setupCamera();
                    this.setupControls();
                    this.setupEventListeners();
                    this.animate();
                    this.updateStatus('已連接', true);
                } catch (error) {
                    console.error('初始化失敗:', error);
                    this.updateStatus('初始化失敗', false);
                }
            }

            async setupMediaPipe() {
                this.faceMesh = new FaceMesh({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                    }
                });

                this.faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                this.faceMesh.onResults((results) => {
                    this.onFaceMeshResults(results);
                });
            }

            setupThreeJS() {
                this.threeCanvas = document.getElementById('threeCanvas');
                
                // 確保使用全局的THREE對象
                const THREE = window.THREE;
                
                // 創建場景
                this.threeScene = new THREE.Scene();
                this.threeScene.background = new THREE.Color(0x000000);
                
                // 創建相機
                this.threeCamera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.threeCamera.position.z = 5;
                
                // 創建渲染器
                this.threeRenderer = new THREE.WebGLRenderer({ 
                    canvas: this.threeCanvas, 
                    alpha: true,
                    antialias: true 
                });
                this.threeRenderer.setSize(window.innerWidth, window.innerHeight);
                this.threeRenderer.setPixelRatio(window.devicePixelRatio);
                
                // 創建面部網格和點
                this.createFaceMesh3D();
                this.createFacePoints();
                
                // 添加燈光
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.threeScene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                this.threeScene.add(directionalLight);
            }

            createFaceMesh3D() {
                // 確保使用全局的THREE對象
                const THREE = window.THREE;
                
                // 創建面部網格幾何體
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                
                // 簡化的面部網格（實際使用時會根據MediaPipe的468個點來創建）
                for (let i = 0; i < 468; i++) {
                    vertices.push(0, 0, 0);
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                
                // 創建材質
                const material = new THREE.MeshBasicMaterial({
                    color: this.settings.meshColor,
                    transparent: true,
                    opacity: this.settings.opacity,
                    wireframe: this.settings.showWireframe
                });
                
                this.faceMesh3D = new THREE.Mesh(geometry, material);
                this.threeScene.add(this.faceMesh3D);
            }

            createFacePoints() {
                // 確保使用全局的THREE對象
                const THREE = window.THREE;
                
                // 創建面部特徵點
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                
                for (let i = 0; i < 468; i++) {
                    vertices.push(0, 0, 0);
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                
                const material = new THREE.PointsMaterial({
                    color: this.settings.meshColor,
                    size: 0.05,
                    transparent: true,
                    opacity: this.settings.opacity
                });
                
                this.facePoints = new THREE.Points(geometry, material);
                this.threeScene.add(this.facePoints);
            }

            async setupCamera() {
                this.videoElement = document.getElementById('videoElement');
                
                try {
                    // 使用MediaPipe的Camera類
                    this.camera = new Camera(this.videoElement, {
                        onFrame: async () => {
                            if (this.faceMesh) {
                                await this.faceMesh.send({ image: this.videoElement });
                            }
                        },
                        width: 1280,
                        height: 720
                    });
                    
                    this.camera.start();
                    this.isTracking = true;
                } catch (error) {
                    console.error('相機訪問失敗:', error);
                    this.updateStatus('相機訪問失敗', false);
                }
            }

            setupControls() {
                // 透明度控制
                const opacitySlider = document.getElementById('opacitySlider');
                const opacityValue = document.getElementById('opacityValue');
                
                opacitySlider.addEventListener('input', (e) => {
                    this.settings.opacity = parseFloat(e.target.value);
                    opacityValue.textContent = this.settings.opacity.toFixed(1);
                    if (this.faceMesh3D) {
                        this.faceMesh3D.material.opacity = this.settings.opacity;
                    }
                    if (this.facePoints) {
                        this.facePoints.material.opacity = this.settings.opacity;
                    }
                });

                // 網格顏色控制
                const meshColor = document.getElementById('meshColor');
                meshColor.addEventListener('change', (e) => {
                    this.settings.meshColor = e.target.value;
                    if (this.faceMesh3D) {
                        this.faceMesh3D.material.color.setHex(parseInt(this.settings.meshColor.replace('#', ''), 16));
                    }
                    if (this.facePoints) {
                        this.facePoints.material.color.setHex(parseInt(this.settings.meshColor.replace('#', ''), 16));
                    }
                });

                // 深度控制
                const depthSlider = document.getElementById('depthSlider');
                const depthValue = document.getElementById('depthValue');
                
                depthSlider.addEventListener('input', (e) => {
                    this.settings.depth = parseFloat(e.target.value);
                    depthValue.textContent = this.settings.depth.toFixed(1);
                });

                // 大小控制
                const scaleSlider = document.getElementById('scaleSlider');
                const scaleValue = document.getElementById('scaleValue');
                
                scaleSlider.addEventListener('input', (e) => {
                    this.settings.scale = parseFloat(e.target.value);
                    scaleValue.textContent = this.settings.scale.toFixed(1);
                });

                // 顯示選項
                document.getElementById('showWireframe').addEventListener('change', (e) => {
                    this.settings.showWireframe = e.target.checked;
                    if (this.faceMesh3D) {
                        this.faceMesh3D.material.wireframe = this.settings.showWireframe;
                    }
                });

                document.getElementById('showPoints').addEventListener('change', (e) => {
                    this.settings.showPoints = e.target.checked;
                    if (this.facePoints) {
                        this.facePoints.visible = this.settings.showPoints;
                    }
                });

                document.getElementById('smoothTracking').addEventListener('change', (e) => {
                    this.settings.smoothTracking = e.target.checked;
                });

                // 3D模型濾鏡控制
                const glbFileInput = document.getElementById('glbFile');
                const loadGLBButton = document.getElementById('loadGLB');
                const removeGLBButton = document.getElementById('removeGLB');
                const modelScaleSlider = document.getElementById('modelScaleSlider');
                const modelRotationSlider = document.getElementById('modelRotationSlider');
                const modelScaleValue = document.getElementById('modelScaleValue');
                const modelRotationValue = document.getElementById('modelRotationValue');

                glbFileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.updateStatus('正在載入3D模型...', true);
                        this.updateModelStatus('載入中...', 'info');
                        this.loadGLBModel(file);
                    }
                });

                loadGLBButton.addEventListener('click', () => {
                    glbFileInput.click();
                });

                removeGLBButton.addEventListener('click', () => {
                    this.removeGLBModel();
                });

                // 測試載入器按鈕
                document.getElementById('testLoader').addEventListener('click', () => {
                    this.testLoader();
                });

                modelScaleSlider.addEventListener('input', (e) => {
                    this.settings.modelScale = parseFloat(e.target.value);
                    modelScaleValue.textContent = this.settings.modelScale.toFixed(1);
                    if (this.customModel) {
                        this.customModel.scale.setScalar(this.settings.modelScale);
                    }
                });

                modelRotationSlider.addEventListener('input', (e) => {
                    this.settings.modelRotationY = parseFloat(e.target.value);
                    modelRotationValue.textContent = this.settings.modelRotationY.toFixed(0);
                    if (this.customModel) {
                        this.customModel.rotation.y = window.THREE.MathUtils.degToRad(this.settings.modelRotationY);
                    }
                });

                // 表情反應強度控制
                const expressionSlider = document.getElementById('expressionSlider');
                const expressionValue = document.getElementById('expressionValue');
                
                expressionSlider.addEventListener('input', (e) => {
                    this.settings.expressionIntensity = parseFloat(e.target.value);
                    expressionValue.textContent = this.settings.expressionIntensity.toFixed(1);
                });

                // 臉部追蹤靈敏度控制
                const trackingSlider = document.getElementById('trackingSlider');
                const trackingValue = document.getElementById('trackingValue');
                
                trackingSlider.addEventListener('input', (e) => {
                    this.settings.trackingSensitivity = parseFloat(e.target.value);
                    trackingValue.textContent = this.settings.trackingSensitivity.toFixed(1);
                });

                // 面具貼合強度控制
                const maskFitSlider = document.getElementById('maskFitSlider');
                const maskFitValue = document.getElementById('maskFitValue');
                
                maskFitSlider.addEventListener('input', (e) => {
                    this.settings.maskFitStrength = parseFloat(e.target.value);
                    maskFitValue.textContent = this.settings.maskFitStrength.toFixed(1);
                });

                // 深度貼合控制
                const depthFitSlider = document.getElementById('depthFitSlider');
                const depthFitValue = document.getElementById('depthFitValue');
                
                depthFitSlider.addEventListener('input', (e) => {
                    this.settings.depthFitStrength = parseFloat(e.target.value);
                    depthFitValue.textContent = this.settings.depthFitStrength.toFixed(1);
                });

                // 按鈕控制
                document.getElementById('resetCamera').addEventListener('click', () => {
                    this.resetCamera();
                });

                document.getElementById('fullscreen').addEventListener('click', () => {
                    this.toggleFullscreen();
                });
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.onWindowResize();
                });

                // 隱藏控制面板的快捷鍵
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'h' || e.key === 'H') {
                        this.toggleControls();
                    }
                });
            }

            onFaceMeshResults(results) {
                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                    const landmarks = results.multiFaceLandmarks[0];
                    this.landmarks = landmarks;
                    
                    this.update3DFaceMesh(landmarks);
                }
            }

            update3DFaceMesh(landmarks) {
                if (!this.faceMesh3D || !this.facePoints) return;
                
                // 更新3D網格頂點位置
                const positions = this.faceMesh3D.geometry.attributes.position.array;
                const pointPositions = this.facePoints.geometry.attributes.position.array;
                
                landmarks.forEach((landmark, index) => {
                    if (index * 3 + 2 < positions.length) {
                        // 將2D座標轉換為3D座標
                        const x = (landmark.x - 0.5) * this.settings.scale;
                        const y = (0.5 - landmark.y) * this.settings.scale;
                        const z = landmark.z * this.settings.depth;
                        
                        positions[index * 3] = x;
                        positions[index * 3 + 1] = y;
                        positions[index * 3 + 2] = z;
                        
                        pointPositions[index * 3] = x;
                        pointPositions[index * 3 + 1] = y;
                        pointPositions[index * 3 + 2] = z;
                    }
                });
                
                this.faceMesh3D.geometry.attributes.position.needsUpdate = true;
                this.facePoints.geometry.attributes.position.needsUpdate = true;
                
                // 根據面部表情調整網格
                this.adjustMeshForExpression(landmarks);
                
                // 更新自定義模型位置（如果存在）
                if (this.customModel) {
                    this.updatePotatoAvatar(landmarks);
                }
            }

            adjustMeshForExpression(landmarks) {
                // 檢測面部表情並調整網格
                if (this.faceMesh3D) {
                    // 根據眼睛開合程度調整
                    const leftEyeOpen = this.calculateEyeOpenness(landmarks, 'left');
                    const rightEyeOpen = this.calculateEyeOpenness(landmarks, 'right');
                    
                    // 根據嘴巴開合程度調整
                    const mouthOpen = this.calculateMouthOpenness(landmarks);
                    
                    // 應用表情變化
                    this.faceMesh3D.scale.setScalar(1 + mouthOpen * 0.1);
                }
            }

            calculateEyeOpenness(landmarks, eye) {
                // 簡化的眼睛開合度計算
                const eyeIndices = eye === 'left' ? [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246] : [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398];
                
                let maxY = -Infinity;
                let minY = Infinity;
                
                eyeIndices.forEach(index => {
                    if (landmarks[index]) {
                        maxY = Math.max(maxY, landmarks[index].y);
                        minY = Math.min(minY, landmarks[index].y);
                    }
                });
                
                return Math.max(0, (maxY - minY) * 10);
            }

            calculateMouthOpenness(landmarks) {
                // 簡化的嘴巴開合度計算
                const mouthIndices = [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468];
                
                let maxY = -Infinity;
                let minY = Infinity;
                
                mouthIndices.forEach(index => {
                    if (landmarks[index]) {
                        maxY = Math.max(maxY, landmarks[index].y);
                        minY = Math.min(minY, landmarks[index].y);
                    }
                });
                
                return Math.max(0, (maxY - minY) * 5);
            }

            resetCamera() {
                if (this.camera) {
                    this.camera.stop();
                    this.setupCamera();
                }
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }

            toggleControls() {
                const controls = document.getElementById('controls');
                controls.style.display = controls.style.display === 'none' ? 'block' : 'none';
            }

            onWindowResize() {
                if (this.threeRenderer) {
                    this.threeCamera.aspect = window.innerWidth / window.innerHeight;
                    this.threeCamera.updateProjectionMatrix();
                    this.threeRenderer.setSize(window.innerWidth, window.innerHeight);
                }
            }

            updateStatus(text, isConnected) {
                const statusText = document.getElementById('statusText');
                const statusIndicator = document.getElementById('statusIndicator');
                
                statusText.textContent = text;
                statusIndicator.className = `status-indicator ${isConnected ? 'status-connected' : 'status-disconnected'}`;
            }

            updateModelStatus(message, type = 'info') {
                const modelStatusEl = document.getElementById('modelStatus');
                if (modelStatusEl) {
                    modelStatusEl.textContent = message;
                    modelStatusEl.style.color = type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : type === 'warning' ? '#ff9800' : '#ccc';
                }
            }

            testLoader() {
                console.log('=== 測試載入器狀態 ===');
                console.log('Three.js版本:', window.THREE.REVISION);
                console.log('GLTFLoader可用:', typeof window.GLTFLoader !== 'undefined');
                console.log('當前設置:', this.settings);
                
                if (typeof window.GLTFLoader === 'undefined') {
                    this.updateModelStatus('GLTFLoader未載入！', 'error');
                    console.error('GLTFLoader未載入');
                } else {
                    this.updateModelStatus('載入器正常', 'success');
                    console.log('載入器狀態正常');
                }
            }

            async loadGLBModel(file) {
                try {
                    if (this.customModel) {
                        this.threeScene.remove(this.customModel);
                        this.customModel = null;
                    }

                    console.log('開始載入模型:', file.name, '大小:', file.size, '類型:', file.type);
                    
                    // 確保使用全局的THREE和GLTFLoader對象
                    const THREE = window.THREE;
                    const GLTFLoader = window.GLTFLoader;
                    
                    // 檢查Three.js和GLTFLoader是否可用
                    if (!THREE) {
                        throw new Error('Three.js未載入');
                    }
                    
                    if (!GLTFLoader) {
                        throw new Error('GLTFLoader未載入');
                    }

                    const loader = new GLTFLoader();
                    const url = URL.createObjectURL(file);
                    
                    console.log('創建URL:', url);
                    
                    // 檢查文件類型
                    if (file.name.toLowerCase().endsWith('.glb')) {
                        console.log('載入GLB文件...');
                        // GLB是二進制格式，直接使用URL
                        loader.load(url, (gltf) => {
                            console.log('GLB載入成功:', gltf);
                            this.onModelLoaded(gltf);
                        }, (progress) => {
                            console.log('載入進度:', progress);
                        }, (error) => {
                            console.error('GLB模型載入失敗:', error);
                            this.updateStatus('GLB模型載入失敗: ' + error.message, false);
                            this.updateModelStatus('載入失敗', 'error');
                        });
                    } else if (file.name.toLowerCase().endsWith('.gltf')) {
                        console.log('載入GLTF文件...');
                        // GLTF是文本格式，需要讀取為JSON
                        const text = await file.text();
                        console.log('GLTF文本內容:', text.substring(0, 200) + '...');
                        const gltfData = JSON.parse(text);
                        console.log('GLTF解析成功:', gltfData);
                        loader.parse(gltfData, url.replace(file.name, ''), (gltf) => {
                            console.log('GLTF解析成功:', gltf);
                            this.onModelLoaded(gltf);
                        }, (error) => {
                            console.error('GLTF模型解析失敗:', error);
                            this.updateStatus('GLTF模型解析失敗: ' + error.message, false);
                            this.updateModelStatus('解析失敗', 'error');
                        });
                    } else {
                        throw new Error('不支持的文件格式，請使用.glb或.gltf文件');
                    }
                    
                    // 延遲釋放URL，確保載入完成
                    setTimeout(() => {
                        URL.revokeObjectURL(url);
                    }, 1000);
                    
                } catch (error) {
                    console.error('載入模型失敗:', error);
                    this.updateStatus('載入模型失敗: ' + error.message, false);
                    this.updateModelStatus('載入失敗: ' + error.message, 'error');
                }
            }

            onModelLoaded(gltf) {
                // 確保使用全局的THREE對象
                const THREE = window.THREE;
                
                this.customModel = gltf.scene;
                
                // 計算模型的邊界框，用於初始定位
                const box = new THREE.Box3().setFromObject(this.customModel);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                // 將模型添加到場景
                this.threeScene.add(this.customModel);
                
                // 初始化模型屬性
                this.customModel.userData = {
                    originalSize: size.clone(),
                    originalCenter: center.clone(),
                    baseScale: this.settings.modelScale,
                    faceOffset: new THREE.Vector3(0, 0, 0),
                    originalGeometry: null,
                    morphedGeometry: null
                };
                
                // 為模型添加變形功能（如果模型有幾何體）
                if (this.customModel.children.length > 0) {
                    const mesh = this.customModel.children.find(child => child.isMesh);
                    if (mesh && mesh.geometry) {
                        // 保存原始幾何體
                        this.customModel.userData.originalGeometry = mesh.geometry.clone();
                        this.customModel.userData.morphedGeometry = mesh.geometry.clone();
                        
                        // 為每個頂點添加變形權重
                        const positions = mesh.geometry.attributes.position;
                        const morphTargets = [];
                        
                        // 創建變形目標（基於臉部網格的關鍵點）
                        const morphTarget = new Float32Array(positions.count * 3);
                        for (let i = 0; i < positions.count; i++) {
                            // 根據頂點在模型中的位置計算變形權重
                            const vertex = new THREE.Vector3();
                            vertex.fromBufferAttribute(positions, i);
                            
                            // 計算到模型中心的距離，用於變形計算
                            const distanceFromCenter = vertex.distanceTo(center);
                            const maxDistance = size.length() * 0.5;
                            
                            // 變形權重（距離中心越近，變形越強）
                            const weight = Math.max(0, 1 - distanceFromCenter / maxDistance);
                            morphTarget[i * 3] = vertex.x * weight * 0.1;
                            morphTarget[i * 3 + 1] = vertex.y * weight * 0.1;
                            morphTarget[i * 3 + 2] = vertex.z * weight * 0.1;
                        }
                        
                        // 添加變形目標
                        mesh.geometry.morphAttributes.position = [new THREE.BufferAttribute(morphTarget, 3)];
                        mesh.morphTargetInfluences = [0]; // 初始變形強度為0
                    }
                }
                
                // 調整模型位置到臉部中心
                this.customModel.position.set(0, 0, 0);
                this.customModel.position.sub(center);
                
                this.updateStatus('3D模型載入成功', true);
                this.updateModelStatus('模型載入成功！', 'success');
                console.log('3D模型載入成功:', gltf);
                console.log('模型尺寸:', size);
                console.log('模型中心:', center);
                console.log('變形功能已啟用');
            }

            removeGLBModel() {
                if (this.customModel) {
                    this.threeScene.remove(this.customModel);
                    this.customModel = null;
                    this.updateStatus('3D模型已移除', true);
                    this.updateModelStatus('模型已移除', 'info');
                }
            }

            updatePotatoAvatar(landmarks) {
                if (!this.customModel || !this.customModel.userData) return;

                // 確保使用全局的THREE對象
                const THREE = window.THREE;

                // 1. 臉部網格貼合 - 使用關鍵臉部特徵點
                const noseCenter = landmarks[1];      // 鼻子中心
                const leftEye = landmarks[33];        // 左眼中心
                const rightEye = landmarks[362];      // 右眼中心
                const leftMouth = landmarks[61];      // 左嘴角
                const rightMouth = landmarks[291];    // 右嘴角
                const leftCheek = landmarks[123];     // 左臉頰
                const rightCheek = landmarks[352];    // 右臉頰
                const chin = landmarks[152];          // 下巴
                const forehead = landmarks[10];       // 額頭

                // 2. 計算臉部網格的實際尺寸和位置
                const faceWidth = Math.abs(rightCheek.x - leftCheek.x) * this.settings.scale;
                const faceHeight = Math.abs(forehead.y - chin.y) * this.settings.scale;
                const faceDepth = Math.abs(noseCenter.z) * this.settings.depth;

                // 3. 計算臉部網格的中心點（不是鼻子，而是整個臉部的幾何中心）
                const faceCenterX = ((leftCheek.x + rightCheek.x) / 2 - 0.5) * this.settings.scale * this.settings.trackingSensitivity;
                const faceCenterY = (0.5 - (forehead.y + chin.y) / 2) * this.settings.scale * this.settings.trackingSensitivity;
                const faceCenterZ = (noseCenter.z - 0.1) * this.settings.depth * this.settings.trackingSensitivity; // 稍微向前偏移

                // 4. 計算臉部旋轉（更精確的計算）
                // 臉部傾斜角度（基於眼睛連線）
                const eyeAngle = Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x);
                
                // 臉部俯仰角度（基於額頭到下巴的連線）
                const facePitch = Math.atan2(forehead.y - chin.y, Math.abs(forehead.x - chin.x));
                
                // 臉部偏航角度（基於臉部寬度變化）
                const faceYaw = Math.atan2(rightCheek.z - leftCheek.z, faceWidth);

                // 5. 計算面具貼合縮放
                // 根據臉部網格的實際尺寸調整模型縮放
                const baseScale = this.settings.modelScale;
                
                // 計算臉部網格與模型的匹配縮放
                const faceAspectRatio = faceWidth / faceHeight;
                const modelAspectRatio = this.customModel.userData.originalSize.x / this.customModel.userData.originalSize.y;
                
                // 根據臉部網格尺寸調整縮放
                const widthScale = faceWidth / this.customModel.userData.originalSize.x;
                const heightScale = faceHeight / this.customModel.userData.originalSize.y;
                
                // 使用較小的縮放值確保完全貼合，並應用面具貼合強度
                const faceScale = Math.min(widthScale, heightScale) * baseScale * this.settings.maskFitStrength;

                // 6. 應用精確的變換到模型
                // 位置：貼合到臉部網格中心
                this.customModel.position.set(faceCenterX, faceCenterY, faceCenterZ);
                
                // 旋轉：完全跟隨臉部網格的旋轉
                this.customModel.rotation.z = eyeAngle;        // 臉部傾斜
                this.customModel.rotation.x = facePitch;       // 臉部俯仰
                this.customModel.rotation.y = faceYaw + window.THREE.MathUtils.degToRad(this.settings.modelRotationY); // 臉部偏航 + 用戶控制
                
                // 縮放：貼合臉部網格尺寸
                this.customModel.scale.setScalar(faceScale);

                // 7. 表情反應 - 更精確的表情貼合
                const mouthOpen = this.calculateMouthOpenness(landmarks);
                const eyeOpen = (this.calculateEyeOpenness(landmarks, 'left') + this.calculateEyeOpenness(landmarks, 'right')) / 2;
                
                // 根據表情微調縮放（使用用戶設置的強度）
                const expressionScale = 1 + (mouthOpen * 0.15 + eyeOpen * 0.1) * this.settings.expressionIntensity;
                this.customModel.scale.multiplyScalar(expressionScale);

                // 8. 網格貼合微調
                // 根據臉部深度調整Z軸位置，確保面具貼合，並應用深度貼合強度
                const depthAdjustment = (faceDepth - this.customModel.userData.originalSize.z) * 0.5 * this.settings.depthFitStrength;
                this.customModel.position.z += depthAdjustment;

                // 9. 應用變形效果（如果可用）
                if (this.customModel.userData.morphedGeometry && this.customModel.children.length > 0) {
                    const mesh = this.customModel.children.find(child => child.isMesh);
                    if (mesh && mesh.morphTargetInfluences && mesh.morphTargetInfluences.length > 0) {
                        // 根據臉部表情調整變形強度
                        const mouthOpen = this.calculateMouthOpenness(landmarks);
                        const eyeOpen = (this.calculateEyeOpenness(landmarks, 'left') + this.calculateEyeOpenness(landmarks, 'right')) / 2;
                        
                        // 變形強度基於表情和臉部運動
                        const morphIntensity = (mouthOpen + eyeOpen) * this.settings.expressionIntensity * 0.5;
                        mesh.morphTargetInfluences[0] = Math.min(1, morphIntensity);
                        
                        // 根據臉部網格形狀調整變形
                        const faceDeformation = Math.abs(faceWidth - faceHeight) / Math.max(faceWidth, faceHeight);
                        mesh.morphTargetInfluences[0] += faceDeformation * 0.3;
                    }
                }

                // 10. 平滑過渡（如果啟用）
                if (this.settings.smoothTracking) {
                    // 使用 lerp 平滑過渡
                    const lerpFactor = 0.1;
                    this.customModel.position.lerp(new THREE.Vector3(faceCenterX, faceCenterY, faceCenterZ + depthAdjustment), lerpFactor);
                    this.customModel.rotation.z = THREE.MathUtils.lerp(this.customModel.rotation.z, eyeAngle, lerpFactor);
                    this.customModel.rotation.x = THREE.MathUtils.lerp(this.customModel.rotation.x, facePitch, lerpFactor);
                    this.customModel.rotation.y = THREE.MathUtils.lerp(this.customModel.rotation.y, faceYaw + window.THREE.MathUtils.degToRad(this.settings.modelRotationY), lerpFactor);
                }

                // 11. 調試信息
                if (this.fpsCounter % 30 === 0) { // 每30幀輸出一次
                    console.log('面具貼合更新:', {
                        faceSize: { width: faceWidth, height: faceHeight, depth: faceDepth },
                        position: this.customModel.position,
                        rotation: this.customModel.rotation,
                        scale: this.customModel.scale,
                        faceScale: faceScale,
                        expressionScale: expressionScale,
                        depthAdjustment: depthAdjustment,
                        morphIntensity: this.customModel.userData.morphedGeometry ? '已啟用' : '未啟用'
                    });
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // 更新FPS計數器
                this.fpsCounter++;
                const currentTime = performance.now();
                
                if (currentTime - this.lastTime >= 1000) {
                    document.getElementById('fpsValue').textContent = this.fpsCounter;
                    this.fpsCounter = 0;
                    this.lastTime = currentTime;
                }
                
                // 渲染3D場景
                if (this.threeRenderer && this.threeScene && this.threeCamera) {
                    this.threeRenderer.render(this.threeScene, this.threeCamera);
                }
            }
        }

        // 開始檢查MediaPipe
        checkMediaPipeWithRetry();
    </script>
</body>
</html>

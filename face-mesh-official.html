<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Mesh OBS - Official Version</title>
    
    <!-- MediaPipe 依賴庫 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .input_video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }

        .output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            z-index: 10;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 10;
            min-width: 280px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .control-group input[type="range"] {
            width: 100%;
        }

        .button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px 0;
            width: 100%;
        }

        .button:hover {
            background: #45a049;
        }

        #fps {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 10px;
            z-index: 10;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="container">
        <video class="input_video" autoplay playsinline></video>
        <canvas class="output_canvas"></canvas>
        
        <div id="status">
            <span id="statusText">初始化中...</span>
        </div>

        <div id="controls">
            <h3 style="margin-bottom: 20px; text-align: center;">Face Mesh 控制</h3>
            
            <div class="control-group">
                <label>網格透明度: <span id="opacityValue">0.8</span></label>
                <input type="range" id="opacitySlider" min="0" max="1" step="0.1" value="0.8">
            </div>

            <div class="control-group">
                <label>網格顏色</label>
                <input type="color" id="meshColor" value="#C0C0C0">
            </div>

            <div class="control-group">
                <label>特徵點顏色</label>
                <input type="color" id="landmarkColor" value="#FF3030">
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showLandmarks" checked> 顯示特徵點
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showMesh" checked> 顯示網格
                </label>
            </div>

            <hr style="margin: 20px 0; border: 1px solid #555;">

            <h4 style="margin-bottom: 15px; text-align: center; color: #ffd700;">人臉面具</h4>
            
            <div class="control-group">
                <label>上傳紋理圖片 (PNG)</label>
                <input type="file" id="textureUpload" accept="image/png,image/jpeg" style="width: 100%; margin-bottom: 10px;">
                <button class="button" id="loadDefaultTexture" style="background: #ff6b35;">載入預設紋理</button>
            </div>

            <div class="control-group">
                <label>上傳3D模型 (GLB)</label>
                <input type="file" id="modelUpload" accept=".glb,.gltf" style="width: 100%; margin-bottom: 10px;">
                <button class="button" id="loadDefaultModel" style="background: #8b4513;">載入預設馬鈴薯模型</button>
                <a href="png-to-potato-glb.html" target="_blank" class="button" style="background: #ff6b35; text-decoration: none; display: inline-block; margin-top: 8px; text-align: center;">🎨 創建自定義GLB模型</a>
            </div>

            <div class="control-group">
                <label>面具透明度: <span id="maskOpacityValue">0.9</span></label>
                <input type="range" id="maskOpacitySlider" min="0" max="1" step="0.1" value="0.9">
            </div>

            <div class="control-group">
                <label>面具縮放: <span id="maskScaleValue">1.0</span></label>
                <input type="range" id="maskScaleSlider" min="0.5" max="2.0" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showMask" checked> 顯示面具
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="cutoutEyes" checked> 挖洞眼睛
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="cutoutMouth" checked> 挖洞嘴巴
                </label>
            </div>

            <div class="control-group">
                <label>挖洞強度: <span id="cutoutStrengthValue">0.8</span></label>
                <input type="range" id="cutoutStrengthSlider" min="0.1" max="1.5" step="0.1" value="0.8">
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="use3DMask" checked> 使用3D面具 (WebGL)
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="useCustomModel" checked> 使用3D模型 (GLB)
                </label>
            </div>

            <div class="control-group">
                <label>3D面具深度: <span id="maskDepthValue">0.1</span></label>
                <input type="range" id="maskDepthSlider" min="0.01" max="0.5" step="0.01" value="0.1">
            </div>

            <hr style="margin: 20px 0; border: 1px solid #555;">

            <button class="button" id="resetCamera">重置相機</button>
            <button class="button" id="toggleFullscreen">全螢幕</button>
        </div>

        <div id="fps">
            FPS: <span id="fpsValue">0</span>
        </div>
    </div>

    <script>
        class OfficialFaceMeshTracker {
            constructor() {
                this.videoElement = document.querySelector('.input_video');
                this.canvasElement = document.querySelector('.output_canvas');
                this.canvasCtx = this.canvasElement.getContext('2d');
                this.faceMesh = null;
                this.camera = null;
                this.isTracking = false;
                this.fpsCounter = 0;
                this.lastTime = 0;
                
                // 面具相關
                this.maskTexture = null;
                this.maskImage = null;
                this.maskCanvas = null;
                this.maskCtx = null;
                
                // 3D面具相關
                this.threeMaskMesh = null;
                this.threeMaskGeometry = null;
                this.threeMaskMaterial = null;
                this.threeMaskTexture = null;
                this.threeScene = null;
                this.threeCamera = null;
                this.threeRenderer = null;
                this.threeMaskContainer = null;
                
                // 3D模型相關
                this.threeModel = null;
                this.threeModelLoader = null;
                this.useCustomModel = false;
                
                // 狀態追蹤
                this.hasShownLandmarkCount = false;
                
                this.settings = {
                    opacity: 0.8,
                    meshColor: '#C0C0C0',
                    landmarkColor: '#FF3030',
                    showLandmarks: true,
                    showMesh: true,
                    // 面具設定
                    showMask: true,
                    maskOpacity: 0.9,
                    maskScale: 1.0,
                    cutoutEyes: true,
                    cutoutMouth: true,
                    cutoutStrength: 0.8,
                    // 3D面具設定
                    use3DMask: true,
                    maskDepth: 0.1
                };
                
                this.init();
            }

            async init() {
                try {
                    await this.setupMediaPipe();
                    this.setupCamera();
                    this.setupMask();
                    this.setupControls();
                    this.setupEventListeners();
                    this.animate();
                    this.updateStatus('已連接', true);
                } catch (error) {
                    console.error('初始化失敗:', error);
                    this.updateStatus('初始化失敗: ' + error.message, false);
                }
            }

            async setupMediaPipe() {
                // 檢查MediaPipe是否可用
                if (typeof FaceMesh === 'undefined') {
                    throw new Error('MediaPipe Face Mesh 未載入');
                }

                this.faceMesh = new FaceMesh({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                    }
                });

                this.faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                this.faceMesh.onResults((results) => {
                    this.onFaceMeshResults(results);
                });
            }

            async setupCamera() {
                try {
                    // 設定canvas尺寸
                    this.canvasElement.width = window.innerWidth;
                    this.canvasElement.height = window.innerHeight;
                    
                    // 使用MediaPipe的Camera類
                    this.camera = new Camera(this.videoElement, {
                        onFrame: async () => {
                            if (this.faceMesh) {
                                await this.faceMesh.send({ image: this.videoElement });
                            }
                        },
                        width: 1280,
                        height: 720
                    });
                    
                    this.camera.start();
                    this.isTracking = true;
                } catch (error) {
                    console.error('相機訪問失敗:', error);
                    this.updateStatus('相機訪問失敗: ' + error.message, false);
                }
            }

            setupMask() {
                // 創建面具canvas
                this.maskCanvas = document.createElement('canvas');
                this.maskCtx = this.maskCanvas.getContext('2d');
                
                // 載入預設紋理
                this.loadDefaultTexture();
                
                // 延遲創建3D面具，確保Three.js已載入
                setTimeout(() => {
                    this.create3DMask();
                }, 100);
            }

            loadDefaultTexture() {
                // 創建馬鈴薯臉紋理
                this.maskCanvas.width = 512;
                this.maskCanvas.height = 512;
                
                // 創建馬鈴薯色背景
                const gradient = this.maskCtx.createRadialGradient(256, 256, 0, 256, 256, 256);
                gradient.addColorStop(0, '#8B4513');
                gradient.addColorStop(0.3, '#A0522D');
                gradient.addColorStop(0.7, '#CD853F');
                gradient.addColorStop(1, '#DEB887');
                
                this.maskCtx.fillStyle = gradient;
                this.maskCtx.fillRect(0, 0, 512, 512);
                
                // 添加馬鈴薯臉的特徵
                this.addPotatoFaceFeatures();
                
                this.maskImage = this.maskCanvas;
                
                // 創建Three.js紋理
                if (this.isThreeJSReady()) {
                    this.threeMaskTexture = new THREE.CanvasTexture(this.maskCanvas);
                    this.threeMaskTexture.needsUpdate = true;
                    
                    // 更新3D面具材質
                    if (this.threeMaskMaterial) {
                        this.threeMaskMaterial.map = this.threeMaskTexture;
                        this.threeMaskMaterial.needsUpdate = true;
                    }
                }
                
                this.updateStatus('馬鈴薯臉紋理已載入，3D面具已創建', true);
            }

            addPotatoFaceFeatures() {
                // 添加馬鈴薯臉的特徵
                
                // 眼睛區域 - 深色
                this.maskCtx.fillStyle = '#654321';
                this.maskCtx.beginPath();
                this.maskCtx.ellipse(200, 200, 30, 20, 0, 0, 2 * Math.PI);
                this.maskCtx.fill();
                
                this.maskCtx.beginPath();
                this.maskCtx.ellipse(312, 200, 30, 20, 0, 0, 2 * Math.PI);
                this.maskCtx.fill();
                
                // 鼻子區域 - 突出
                this.maskCtx.fillStyle = '#A0522D';
                this.maskCtx.beginPath();
                this.maskCtx.ellipse(256, 250, 15, 25, 0, 0, 2 * Math.PI);
                this.maskCtx.fill();
                
                // 嘴巴區域 - 微笑
                this.maskCtx.strokeStyle = '#654321';
                this.maskCtx.lineWidth = 8;
                this.maskCtx.beginPath();
                this.maskCtx.arc(256, 300, 40, 0, Math.PI);
                this.maskCtx.stroke();
                
                // 添加馬鈴薯的斑點和紋理
                this.maskCtx.fillStyle = '#654321';
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * 512;
                    const y = Math.random() * 512;
                    const size = Math.random() * 8 + 2;
                    
                    this.maskCtx.beginPath();
                    this.maskCtx.arc(x, y, size, 0, 2 * Math.PI);
                    this.maskCtx.fill();
                }
                
                // 添加高光效果
                this.maskCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.maskCtx.beginPath();
                this.maskCtx.ellipse(200, 150, 40, 20, Math.PI / 4, 0, 2 * Math.PI);
                this.maskCtx.fill();
                
                this.maskCtx.beginPath();
                this.maskCtx.ellipse(312, 150, 40, 20, -Math.PI / 4, 0, 2 * Math.PI);
                this.maskCtx.fill();
            }

            // MediaPipe Face Mesh UV座標對應表
            getFaceMeshUVs() {
                // 這是MediaPipe Face Mesh的標準UV座標
                // 每個頂點對應到紋理圖的UV座標 (u, v)
                const uvs = [];
                
                // 生成478個頂點的UV座標 (支援新版本MediaPipe)
                // 臉部中心為(0.5, 0.5)，邊緣為(0,0)和(1,1)
                for (let i = 0; i < 478; i++) {
                    // 根據頂點索引計算UV座標
                    // 這裡使用更精確的UV映射，基於MediaPipe的標準佈局
                    let u, v;
                    
                    if (i < 10) {
                        // 臉部輪廓 - 圓形分佈
                        const angle = (i / 10) * 2 * Math.PI;
                        u = 0.5 + Math.cos(angle) * 0.4;
                        v = 0.5 + Math.sin(angle) * 0.4;
                    } else if (i < 33) {
                        // 臉部輪廓延伸
                        const t = (i - 10) / 23;
                        u = 0.5 + Math.cos(t * 2 * Math.PI) * (0.4 - t * 0.1);
                        v = 0.5 + Math.sin(t * 2 * Math.PI) * (0.4 - t * 0.1);
                    } else if (i < 47) {
                        // 左眼區域
                        const t = (i - 33) / 14;
                        u = 0.35 + Math.cos(t * 2 * Math.PI) * 0.15;
                        v = 0.4 + Math.sin(t * 2 * Math.PI) * 0.1;
                    } else if (i < 61) {
                        // 左眼眉毛
                        const t = (i - 47) / 14;
                        u = 0.35 + Math.cos(t * 2 * Math.PI) * 0.15;
                        v = 0.3 + Math.sin(t * 2 * Math.PI) * 0.1;
                    } else if (i < 75) {
                        // 右眼眉毛
                        const t = (i - 61) / 14;
                        u = 0.65 + Math.cos(t * 2 * Math.PI) * 0.15;
                        v = 0.3 + Math.sin(t * 2 * Math.PI) * 0.1;
                    } else if (i < 89) {
                        // 右眼區域
                        const t = (i - 75) / 14;
                        u = 0.65 + Math.cos(t * 2 * Math.PI) * 0.15;
                        v = 0.4 + Math.sin(t * 2 * Math.PI) * 0.1;
                    } else if (i < 100) {
                        // 鼻子區域
                        const t = (i - 89) / 11;
                        u = 0.5 + Math.cos(t * Math.PI) * 0.1;
                        v = 0.45 + t * 0.1;
                    } else if (i < 150) {
                        // 臉部主要區域 - 橢圓分佈
                        const t = (i - 100) / 50;
                        const angle = t * 2 * Math.PI;
                        u = 0.5 + Math.cos(angle) * (0.3 - t * 0.1);
                        v = 0.5 + Math.sin(angle) * (0.25 - t * 0.1);
                    } else if (i < 200) {
                        // 臉部填充區域
                        const t = (i - 150) / 50;
                        u = 0.5 + (Math.random() - 0.5) * 0.2;
                        v = 0.5 + (Math.random() - 0.5) * 0.2;
                    } else if (i < 250) {
                        // 嘴巴外圍
                        const t = (i - 200) / 50;
                        const angle = t * 2 * Math.PI;
                        u = 0.5 + Math.cos(angle) * 0.25;
                        v = 0.6 + Math.sin(angle) * 0.15;
                    } else if (i < 300) {
                        // 嘴巴內部
                        const t = (i - 250) / 50;
                        const angle = t * 2 * Math.PI;
                        u = 0.5 + Math.cos(angle) * 0.15;
                        v = 0.6 + Math.sin(angle) * 0.1;
                    } else if (i < 350) {
                        // 臉部邊緣填充
                        const t = (i - 300) / 50;
                        u = 0.5 + (Math.random() - 0.5) * 0.3;
                        v = 0.5 + (Math.random() - 0.5) * 0.3;
                    } else if (i < 400) {
                        // 臉部細節填充
                        const t = (i - 350) / 50;
                        u = 0.5 + (Math.random() - 0.5) * 0.25;
                        v = 0.5 + (Math.random() - 0.5) * 0.25;
                    } else if (i < 450) {
                        // 臉部細節填充
                        const t = (i - 400) / 50;
                        u = 0.5 + (Math.random() - 0.5) * 0.25;
                        v = 0.5 + (Math.random() - 0.5) * 0.25;
                    } else {
                        // 剩餘頂點 (450-477) - 均勻分佈
                        const t = (i - 450) / 28;
                        u = 0.5 + (Math.random() - 0.5) * 0.2;
                        v = 0.5 + (Math.random() - 0.5) * 0.2;
                    }
                    
                    // 確保UV座標在[0,1]範圍內
                    u = Math.max(0, Math.min(1, u));
                    v = Math.max(0, Math.min(1, v));
                    
                    uvs.push(u, v);
                }
                
                return uvs;
            }

            isThreeJSReady() {
                return typeof THREE !== 'undefined' && 
                       typeof THREE.Scene !== 'undefined' && 
                       typeof THREE.BufferGeometry !== 'undefined' && 
                       typeof THREE.Mesh !== 'undefined' && 
                       typeof THREE.MeshBasicMaterial !== 'undefined' && 
                       typeof THREE.WebGLRenderer !== 'undefined';
            }

            is3DMaskReady() {
                if (this.useCustomModel) {
                    return this.threeModel && this.threeScene;
                } else {
                    return this.threeMaskMesh && 
                           this.threeMaskGeometry && 
                           this.threeMaskMaterial &&
                           this.threeMaskGeometry.attributes.position &&
                           this.threeMaskGeometry.attributes.position.array &&
                           this.threeMaskGeometry.attributes.position.array.length >= 478 * 3;
                }
            }

            loadGLBModel(file) {
                if (!this.isThreeJSReady()) {
                    console.warn('Three.js 未完全載入，無法載入GLB模型');
                    return;
                }

                if (!this.threeModelLoader) {
                    // 創建GLTFLoader
                    this.threeModelLoader = new THREE.GLTFLoader();
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const arrayBuffer = e.target.result;
                    
                    this.threeModelLoader.parse(arrayBuffer, '', (gltf) => {
                        console.log('GLB模型載入成功:', gltf);
                        
                        // 移除舊的模型
                        if (this.threeModel) {
                            this.threeScene.remove(this.threeModel);
                        }
                        
                        // 獲取模型
                        this.threeModel = gltf.scene;
                        
                        // 調整模型大小和位置
                        this.threeModel.scale.set(0.1, 0.1, 0.1);
                        this.threeModel.position.set(0, 0, 0);
                        
                        // 添加到場景
                        this.threeScene.add(this.threeModel);
                        
                        // 標記使用自定義模型
                        this.useCustomModel = true;
                        
                        this.updateStatus('GLB模型已載入', true);
                    }, (error) => {
                        console.error('GLB模型載入失敗:', error);
                        this.updateStatus('GLB模型載入失敗: ' + error.message, false);
                    });
                };
                
                reader.readAsArrayBuffer(file);
            }

            loadDefaultPotatoModel() {
                if (!this.isThreeJSReady()) {
                    console.warn('Three.js 未完全載入，無法載入預設模型');
                    return;
                }

                // 創建一個簡單的馬鈴薯形狀幾何體
                const potatoGeometry = new THREE.SphereGeometry(1, 8, 6);
                
                // 創建馬鈴薯材質
                const potatoMaterial = new THREE.MeshLambertMaterial({
                    color: 0x8B4513,
                    transparent: true,
                    opacity: this.settings.maskOpacity
                });
                
                // 創建馬鈴薯網格
                this.threeModel = new THREE.Mesh(potatoGeometry, potatoMaterial);
                
                // 調整大小和位置
                this.threeModel.scale.set(0.8, 1.2, 0.8);
                this.threeModel.position.set(0, 0, 0);
                
                // 添加到場景
                if (this.threeScene) {
                    this.threeScene.add(this.threeModel);
                }
                
                // 標記使用預設模型
                this.useCustomModel = true;
                
                this.updateStatus('預設馬鈴薯模型已載入', true);
            }

            create3DMask() {
                // 檢查Three.js是否完全載入
                if (!this.isThreeJSReady()) {
                    console.warn('Three.js 未完全載入，3D面具將不可用');
                    this.updateStatus('等待Three.js載入...', false);
                    // 使用輪詢機制等待Three.js載入
                    setTimeout(() => this.create3DMask(), 100);
                    return;
                }

                // 按照用戶建議的優化方式建立 geometry
                this.threeMaskGeometry = new THREE.BufferGeometry();
                
                // 創建初始頂點位置 (支援478個點，兼容新版本MediaPipe)
                const maxVertices = 478; // 支援新版本的MediaPipe Face Mesh
                const initialVertices = new Float32Array(maxVertices * 3);
                for (let i = 0; i < maxVertices; i++) {
                    initialVertices[i * 3] = 0;     // x
                    initialVertices[i * 3 + 1] = 0; // y
                    initialVertices[i * 3 + 2] = 0; // z
                }
                
                // 創建UV座標
                const uvs = new Float32Array(this.getFaceMeshUVs());
                
                // 設置幾何體屬性
                this.threeMaskGeometry.setAttribute('position', new THREE.BufferAttribute(initialVertices, 3));
                this.threeMaskGeometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
                
                // 創建三角形索引
                const triangles = this.createFaceMeshTriangles();
                const indices = [];
                triangles.forEach(triangle => {
                    indices.push(...triangle);
                });
                
                this.threeMaskGeometry.setIndex(indices);
                
                // 計算法向量
                this.threeMaskGeometry.computeVertexNormals();
                
                // 貼材質
                this.threeMaskMaterial = new THREE.MeshBasicMaterial({ 
                    map: this.threeMaskTexture, 
                    transparent: true,
                    opacity: this.settings.maskOpacity,
                    side: THREE.DoubleSide
                });
                
                // 建立 mesh
                this.threeMaskMesh = new THREE.Mesh(this.threeMaskGeometry, this.threeMaskMaterial);
                
                // 創建Three.js場景（如果還沒有的話）
                if (!this.threeScene) {
                    this.createThreeJSScene();
                }
                
                // 添加到Three.js場景
                this.threeScene.add(this.threeMaskMesh);
                
                console.log('3D面具創建成功，頂點數:', this.threeMaskGeometry.attributes.position.count);
                console.log('三角形數:', this.threeMaskGeometry.index ? this.threeMaskGeometry.index.count / 3 : 0);
                console.log('支援的最大頂點數:', maxVertices);
                this.updateStatus('3D面具已創建', true);
            }

            createFaceMeshTriangles() {
                // 創建面部網格的三角形索引
                // 使用更高效的三角形生成方式
                const triangles = [];
                
                // 臉部主要區域 - 使用扇狀三角形填充
                const faceCenter = 10; // 臉部中心點
                const faceOutline = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109];
                
                // 臉部輪廓三角形
                for (let i = 0; i < faceOutline.length - 1; i++) {
                    triangles.push([faceCenter, faceOutline[i], faceOutline[i + 1]]);
                }
                triangles.push([faceCenter, faceOutline[faceOutline.length - 1], faceOutline[0]]);
                
                // 左眼區域
                const leftEyeCenter = 33;
                const leftEyeOutline = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246];
                for (let i = 0; i < leftEyeOutline.length - 1; i++) {
                    triangles.push([leftEyeCenter, leftEyeOutline[i], leftEyeOutline[i + 1]]);
                }
                triangles.push([leftEyeCenter, leftEyeOutline[leftEyeOutline.length - 1], leftEyeOutline[0]]);
                
                // 右眼區域
                const rightEyeCenter = 362;
                const rightEyeOutline = [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398];
                for (let i = 0; i < rightEyeOutline.length - 1; i++) {
                    triangles.push([rightEyeCenter, rightEyeOutline[i], rightEyeOutline[i + 1]]);
                }
                triangles.push([rightEyeCenter, rightEyeOutline[rightEyeOutline.length - 1], rightEyeOutline[0]]);
                
                // 鼻子區域
                const noseCenter = 1;
                const noseOutline = [1, 2, 3, 4, 5, 6, 168, 8, 9, 10, 151, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468];
                for (let i = 0; i < noseOutline.length - 1; i++) {
                    triangles.push([noseCenter, noseOutline[i], noseOutline[i + 1]]);
                }
                triangles.push([noseCenter, noseOutline[noseOutline.length - 1], noseOutline[0]]);
                
                // 嘴巴區域
                const mouthCenter = 13;
                const mouthOutline = [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468];
                for (let i = 0; i < mouthOutline.length - 1; i++) {
                    triangles.push([mouthCenter, mouthOutline[i], mouthOutline[i + 1]]);
                }
                triangles.push([mouthCenter, mouthOutline[mouthOutline.length - 1], mouthOutline[0]]);
                
                console.log('創建三角形索引，總數:', triangles.length);
                console.log('臉部輪廓三角形:', faceOutline.length - 1);
                console.log('左眼三角形:', leftEyeOutline.length - 1);
                console.log('右眼三角形:', rightEyeOutline.length - 1);
                console.log('鼻子三角形:', noseOutline.length - 1);
                console.log('嘴巴三角形:', mouthOutline.length - 1);
                
                return triangles;
            }

            createThreeJSScene() {
                if (!this.isThreeJSReady()) {
                    console.warn('Three.js 未完全載入，無法創建3D場景');
                    return;
                }

                // 創建場景
                this.threeScene = new THREE.Scene();
                
                // 創建相機
                this.threeCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.threeCamera.position.z = 5;
                
                // 創建渲染器
                this.threeRenderer = new THREE.WebGLRenderer({ 
                    alpha: true, 
                    antialias: true,
                    preserveDrawingBuffer: true
                });
                this.threeRenderer.setSize(window.innerWidth, window.innerHeight);
                this.threeRenderer.setClearColor(0x000000, 0);
                
                // 創建3D面具容器
                this.threeMaskContainer = document.createElement('div');
                this.threeMaskContainer.style.position = 'absolute';
                this.threeMaskContainer.style.top = '0';
                this.threeMaskContainer.style.left = '0';
                this.threeMaskContainer.style.width = '100%';
                this.threeMaskContainer.style.height = '100%';
                this.threeMaskContainer.style.zIndex = '3';
                this.threeMaskContainer.style.pointerEvents = 'none';
                
                // 將渲染器添加到容器
                this.threeMaskContainer.appendChild(this.threeRenderer.domElement);
                
                // 添加到主容器
                const container = document.getElementById('container');
                if (container) {
                    container.appendChild(this.threeMaskContainer);
                }
                
                // 添加光源
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.threeScene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(0, 1, 1);
                this.threeScene.add(directionalLight);
                
                // 開始渲染循環
                this.animateThreeJS();
                
                // 添加窗口大小調整監聽器
                window.addEventListener('resize', () => {
                    if (this.threeCamera && this.threeRenderer) {
                        this.threeCamera.aspect = window.innerWidth / window.innerHeight;
                        this.threeCamera.updateProjectionMatrix();
                        this.threeRenderer.setSize(window.innerWidth, window.innerHeight);
                    }
                });
            }

            animateThreeJS() {
                if (!this.threeScene || !this.threeRenderer || !this.threeCamera) return;
                
                // 渲染場景
                this.threeRenderer.render(this.threeScene, this.threeCamera);
                
                // 繼續動畫循環
                requestAnimationFrame(() => this.animateThreeJS());
            }

            update3DMask(landmarks) {
                if (!this.is3DMaskReady() || !this.settings.use3DMask || !landmarks || landmarks.length === 0) {
                    return;
                }
                
                try {
                    if (this.useCustomModel && this.threeModel) {
                        // 更新3D模型位置和旋轉
                        this.update3DModel(landmarks);
                    } else {
                        // 更新幾何體頂點
                        this.updateGeometryVertices(landmarks);
                    }
                } catch (error) {
                    console.error('更新3D面具時發生錯誤:', error);
                    throw error; // 重新拋出錯誤，讓調用者處理
                }
            }

            update3DModel(landmarks) {
                if (!this.threeModel || landmarks.length === 0) return;
                
                // 計算面部中心點
                const centerX = landmarks.reduce((sum, p) => sum + p.x, 0) / landmarks.length;
                const centerY = landmarks.reduce((sum, p) => sum + p.y, 0) / landmarks.length;
                const centerZ = landmarks.reduce((sum, p) => sum + p.z, 0) / landmarks.length;
                
                // 計算面部大小
                const faceWidth = Math.max(...landmarks.map(p => p.x)) - Math.min(...landmarks.map(p => p.x));
                const faceHeight = Math.max(...landmarks.map(p => p.y)) - Math.min(...landmarks.map(p => p.y));
                const faceSize = Math.max(faceWidth, faceHeight);
                
                // 更新模型位置
                this.threeModel.position.x = (centerX - 0.5) * 10;
                this.threeModel.position.y = (0.5 - centerY) * 10;
                this.threeModel.position.z = centerZ * 5 + this.settings.maskDepth;
                
                // 根據面部大小調整模型縮放
                const scale = faceSize * 20 * this.settings.maskScale;
                this.threeModel.scale.set(scale, scale, scale);
                
                // 根據面部傾斜調整模型旋轉
                const leftEye = landmarks[33]; // 左眼中心
                const rightEye = landmarks[362]; // 右眼中心
                if (leftEye && rightEye) {
                    const eyeAngle = Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x);
                    this.threeModel.rotation.z = eyeAngle;
                }
            }

            updateGeometryVertices(landmarks) {
                // 檢查頂點數量是否匹配 (支援468和478)
                if (landmarks.length !== 468 && landmarks.length !== 478) {
                    console.warn('Landmarks數量不匹配，期望468或478，實際:', landmarks.length);
                    return;
                }
                
                // 獲取現有的頂點陣列
                const positions = this.threeMaskGeometry.attributes.position;
                
                // 逐個更新頂點位置，避免超出緩衝區
                for (let i = 0; i < landmarks.length && i < 478; i++) {
                    const landmark = landmarks[i];
                    if (landmark && i * 3 + 2 < positions.array.length) {
                        positions.array[i * 3] = (landmark.x - 0.5) * 10;      // x座標轉換
                        positions.array[i * 3 + 1] = (0.5 - landmark.y) * 10;  // y座標轉換
                        positions.array[i * 3 + 2] = landmark.z * 5 + this.settings.maskDepth;  // z座標轉換
                    }
                }
                
                // 標記頂點陣列需要更新
                positions.needsUpdate = true;
                
                // 重新計算法向量
                this.threeMaskGeometry.computeVertexNormals();
            }

            loadCustomTexture(file) {
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // 創建新的canvas來處理紋理
                        this.maskCanvas.width = img.width;
                        this.maskCanvas.height = img.height;
                        this.maskCtx.clearRect(0, 0, img.width, img.height);
                        this.maskCtx.drawImage(img, 0, 0);
                        
                        this.maskImage = this.maskCanvas;
                        
                        // 創建Three.js紋理
                        if (this.isThreeJSReady()) {
                            this.threeMaskTexture = new THREE.CanvasTexture(this.maskCanvas);
                            this.threeMaskTexture.needsUpdate = true;
                            
                            // 更新3D面具材質
                            if (this.threeMaskMaterial) {
                                this.threeMaskMaterial.map = this.threeMaskTexture;
                                this.threeMaskMaterial.needsUpdate = true;
                            }
                        }
                        
                        this.updateStatus('自定義紋理已載入', true);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            drawMask(landmarks) {
                if (!this.settings.showMask || !this.maskImage) return;
                
                const canvas = this.canvasElement;
                const ctx = this.canvasCtx;
                
                ctx.save();
                ctx.globalAlpha = this.settings.maskOpacity;
                
                // 計算面部邊界框
                const bounds = this.getFaceBounds(landmarks);
                const faceWidth = bounds.width * this.settings.maskScale;
                const faceHeight = bounds.height * this.settings.maskScale;
                const faceX = bounds.x - (faceWidth - bounds.width) / 2;
                const faceY = bounds.y - (faceHeight - bounds.height) / 2;
                
                // 繪製面具
                ctx.drawImage(this.maskImage, faceX, faceY, faceWidth, faceHeight);
                
                // 應用挖洞效果
                if (this.settings.cutoutEyes) {
                    this.applyEyeCutout(ctx, landmarks);
                }
                
                if (this.settings.cutoutMouth) {
                    this.applyMouthCutout(ctx, landmarks);
                }
                
                ctx.restore();
            }

            getFaceBounds(landmarks) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                
                // 臉部輪廓點
                const faceOutline = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109];
                
                faceOutline.forEach(index => {
                    if (landmarks[index]) {
                        const x = landmarks[index].x * this.canvasElement.width;
                        const y = landmarks[index].y * this.canvasElement.height;
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                });
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }

            applyEyeCutout(ctx, landmarks) {
                // 左眼挖洞
                this.applyCutout(ctx, landmarks, [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246]);
                
                // 右眼挖洞
                this.applyCutout(ctx, landmarks, [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398]);
            }

            applyMouthCutout(ctx, landmarks) {
                // 嘴巴挖洞
                this.applyCutout(ctx, landmarks, [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468]);
            }

            applyCutout(ctx, landmarks, indices) {
                if (indices.length < 3) return;
                
                const canvas = this.canvasElement;
                const points = indices.map(index => {
                    if (landmarks[index]) {
                        return {
                            x: landmarks[index].x * canvas.width,
                            y: landmarks[index].y * canvas.height
                        };
                    }
                    return null;
                }).filter(p => p !== null);
                
                if (points.length < 3) return;
                
                // 創建挖洞路徑
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                
                ctx.closePath();
                
                // 使用合成模式創建挖洞效果
                ctx.globalCompositeOperation = 'destination-out';
                ctx.fillStyle = `rgba(0, 0, 0, ${this.settings.cutoutStrength})`;
                ctx.fill();
                
                // 恢復合成模式
                ctx.globalCompositeOperation = 'source-over';
            }

            setupControls() {
                // 透明度控制
                const opacitySlider = document.getElementById('opacitySlider');
                const opacityValue = document.getElementById('opacityValue');
                
                opacitySlider.addEventListener('input', (e) => {
                    this.settings.opacity = parseFloat(e.target.value);
                    opacityValue.textContent = this.settings.opacity.toFixed(1);
                });

                // 網格顏色控制
                const meshColor = document.getElementById('meshColor');
                meshColor.addEventListener('change', (e) => {
                    this.settings.meshColor = e.target.value;
                });

                // 特徵點顏色控制
                const landmarkColor = document.getElementById('landmarkColor');
                landmarkColor.addEventListener('change', (e) => {
                    this.settings.landmarkColor = e.target.value;
                });

                // 顯示選項
                document.getElementById('showLandmarks').addEventListener('change', (e) => {
                    this.settings.showLandmarks = e.target.checked;
                });

                document.getElementById('showMesh').addEventListener('change', (e) => {
                    this.settings.showMesh = e.target.checked;
                });

                // 面具控制
                document.getElementById('showMask').addEventListener('change', (e) => {
                    this.settings.showMask = e.target.checked;
                });

                document.getElementById('cutoutEyes').addEventListener('change', (e) => {
                    this.settings.cutoutEyes = e.target.checked;
                });

                document.getElementById('cutoutMouth').addEventListener('change', (e) => {
                    this.settings.cutoutMouth = e.target.checked;
                });

                // 面具透明度控制
                const maskOpacitySlider = document.getElementById('maskOpacitySlider');
                const maskOpacityValue = document.getElementById('maskOpacityValue');
                
                maskOpacitySlider.addEventListener('input', (e) => {
                    this.settings.maskOpacity = parseFloat(e.target.value);
                    maskOpacityValue.textContent = this.settings.maskOpacity.toFixed(1);
                });

                // 面具縮放控制
                const maskScaleSlider = document.getElementById('maskScaleSlider');
                const maskScaleValue = document.getElementById('maskScaleValue');
                
                maskScaleSlider.addEventListener('input', (e) => {
                    this.settings.maskScale = parseFloat(e.target.value);
                    maskScaleValue.textContent = this.settings.maskScale.toFixed(1);
                });

                // 挖洞強度控制
                const cutoutStrengthSlider = document.getElementById('cutoutStrengthSlider');
                const cutoutStrengthValue = document.getElementById('cutoutStrengthValue');
                
                cutoutStrengthSlider.addEventListener('input', (e) => {
                    this.settings.cutoutStrength = parseFloat(e.target.value);
                    cutoutStrengthValue.textContent = this.settings.cutoutStrength.toFixed(1);
                });

                // 3D面具控制
                document.getElementById('use3DMask').addEventListener('change', (e) => {
                    this.settings.use3DMask = e.target.checked;
                });

                // 3D模型控制
                document.getElementById('useCustomModel').addEventListener('change', (e) => {
                    this.settings.useCustomModel = e.target.checked;
                    this.useCustomModel = e.target.checked;
                });

                // 3D面具深度控制
                const maskDepthSlider = document.getElementById('maskDepthSlider');
                const maskDepthValue = document.getElementById('maskDepthValue');
                
                maskDepthSlider.addEventListener('input', (e) => {
                    this.settings.maskDepth = parseFloat(e.target.value);
                    maskDepthValue.textContent = this.settings.maskDepth.toFixed(2);
                });

                // 紋理上傳
                document.getElementById('textureUpload').addEventListener('change', (e) => {
                    this.loadCustomTexture(e.target.files[0]);
                });

                // 載入預設紋理
                document.getElementById('loadDefaultTexture').addEventListener('click', () => {
                    this.loadDefaultTexture();
                });

                // 載入GLB模型
                document.getElementById('modelUpload').addEventListener('change', (e) => {
                    this.loadGLBModel(e.target.files[0]);
                });

                // 載入預設馬鈴薯模型
                document.getElementById('loadDefaultModel').addEventListener('click', () => {
                    this.loadDefaultPotatoModel();
                });

                // 重置相機
                document.getElementById('resetCamera').addEventListener('click', () => {
                    this.resetCamera();
                });

                // 全螢幕
                document.getElementById('toggleFullscreen').addEventListener('click', () => {
                    this.toggleFullscreen();
                });
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.onWindowResize();
                });

                // 隱藏控制面板的快捷鍵
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'h' || e.key === 'H') {
                        this.toggleControls();
                    }
                });
            }

            onFaceMeshResults(results) {
                this.canvasCtx.save();
                this.canvasCtx.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
                
                // 繪製原始視訊
                this.canvasCtx.drawImage(results.image, 0, 0, this.canvasElement.width, this.canvasElement.height);
                
                if (results.multiFaceLandmarks) {
                    for (const landmarks of results.multiFaceLandmarks) {
                        // 顯示landmarks數量信息（僅在第一次檢測到時）
                        if (!this.hasShownLandmarkCount) {
                            console.log('檢測到MediaPipe Face Mesh版本，landmarks數量:', landmarks.length);
                            this.hasShownLandmarkCount = true;
                        }
                        
                        // 嘗試更新3D面具，如果失敗則回退到2D模式
                        if (this.settings.use3DMask && (this.threeMaskMesh || this.threeModel)) {
                            try {
                                this.update3DMask(landmarks);
                            } catch (error) {
                                console.warn('3D面具更新失敗，回退到2D模式:', error);
                                this.settings.use3DMask = false;
                                // 更新UI狀態
                                const use3DMaskCheckbox = document.getElementById('use3DMask');
                                if (use3DMaskCheckbox) {
                                    use3DMaskCheckbox.checked = false;
                                }
                                // 繪製2D面具
                                this.drawMask(landmarks);
                            }
                        } else {
                            // 繪製2D面具（在網格和特徵點下方）
                            this.drawMask(landmarks);
                        }
                        
                        if (this.settings.showMesh) {
                            // 繪製網格
                            this.drawConnectors(this.canvasCtx, landmarks, FACEMESH_TESSELATION, {
                                color: this.settings.meshColor + Math.floor(this.settings.opacity * 255).toString(16).padStart(2, '0')
                            });
                        }
                        
                        if (this.settings.showLandmarks) {
                            // 繪製特徵點
                            this.drawLandmarks(this.canvasCtx, landmarks, {
                                color: this.settings.landmarkColor,
                                lineWidth: 1
                            });
                        }
                    }
                }
                
                this.canvasCtx.restore();
            }

            drawConnectors(ctx, landmarks, connections, style) {
                const canvas = this.canvasElement;
                
                ctx.strokeStyle = style.color;
                ctx.lineWidth = style.lineWidth || 1;
                
                connections.forEach(([start, end]) => {
                    if (landmarks[start] && landmarks[end]) {
                        const startX = landmarks[start].x * canvas.width;
                        const startY = landmarks[start].y * canvas.height;
                        const endX = landmarks[end].x * canvas.width;
                        const endY = landmarks[end].y * canvas.height;
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                    }
                });
            }

            drawLandmarks(ctx, landmarks, style) {
                const canvas = this.canvasElement;
                
                ctx.fillStyle = style.color;
                ctx.lineWidth = style.lineWidth || 1;
                
                landmarks.forEach(landmark => {
                    const x = landmark.x * canvas.width;
                    const y = landmark.y * canvas.height;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }

            resetCamera() {
                if (this.camera) {
                    this.camera.stop();
                    this.setupCamera();
                }
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }

            toggleControls() {
                const controls = document.getElementById('controls');
                controls.style.display = controls.style.display === 'none' ? 'block' : 'none';
            }

            onWindowResize() {
                this.canvasElement.width = window.innerWidth;
                this.canvasElement.height = window.innerHeight;
            }

            updateStatus(text, isConnected) {
                const statusText = document.getElementById('statusText');
                statusText.textContent = text;
                statusText.style.color = isConnected ? '#4CAF50' : '#f44336';
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // 更新FPS計數器
                this.fpsCounter++;
                const currentTime = performance.now();
                
                if (currentTime - this.lastTime >= 1000) {
                    document.getElementById('fpsValue').textContent = this.fpsCounter;
                    this.fpsCounter = 0;
                    this.lastTime = currentTime;
                }
            }
        }

        // 當頁面加載完成後初始化
        document.addEventListener('DOMContentLoaded', () => {
            // 等待MediaPipe載入
            let retryCount = 0;
            const maxRetries = 20;
            
            function checkMediaPipe() {
                if (retryCount >= maxRetries) {
                    console.error('MediaPipe 載入失敗，請檢查網路連接');
                    document.getElementById('statusText').textContent = 'MediaPipe 載入失敗';
                    return;
                }
                
                if (typeof FaceMesh !== 'undefined' && typeof Camera !== 'undefined') {
                    console.log('MediaPipe 已載入，開始初始化...');
                    new OfficialFaceMeshTracker();
                } else {
                    retryCount++;
                    console.log(`等待 MediaPipe 載入... (嘗試 ${retryCount}/${maxRetries})`);
                    setTimeout(checkMediaPipe, 500);
                }
            }
            
            checkMediaPipe();
        });
    </script>
</body>
</html>

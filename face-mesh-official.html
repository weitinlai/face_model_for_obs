<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Mesh OBS - Official Version</title>
    
    <!-- MediaPipe ä¾è³´åº« -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .input_video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }

        .output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            z-index: 10;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 10;
            min-width: 280px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .control-group input[type="range"] {
            width: 100%;
        }

        .button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px 0;
            width: 100%;
        }

        .button:hover {
            background: #45a049;
        }

        #fps {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 10px;
            z-index: 10;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="container">
        <video class="input_video" autoplay playsinline></video>
        <canvas class="output_canvas"></canvas>
        
        <div id="status">
            <span id="statusText">åˆå§‹åŒ–ä¸­...</span>
        </div>

        <div id="controls">
            <h3 style="margin-bottom: 20px; text-align: center;">Face Mesh æ§åˆ¶</h3>
            
            <div class="control-group">
                <label>ç¶²æ ¼é€æ˜åº¦: <span id="opacityValue">0.8</span></label>
                <input type="range" id="opacitySlider" min="0" max="1" step="0.1" value="0.8">
            </div>

            <div class="control-group">
                <label>ç¶²æ ¼é¡è‰²</label>
                <input type="color" id="meshColor" value="#C0C0C0">
            </div>

            <div class="control-group">
                <label>ç‰¹å¾µé»é¡è‰²</label>
                <input type="color" id="landmarkColor" value="#FF3030">
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showLandmarks" checked> é¡¯ç¤ºç‰¹å¾µé»
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showMesh" checked> é¡¯ç¤ºç¶²æ ¼
                </label>
            </div>

            <hr style="margin: 20px 0; border: 1px solid #555;">

            <h4 style="margin-bottom: 15px; text-align: center; color: #ffd700;">äººè‡‰é¢å…·</h4>
            
            <div class="control-group">
                <label>ä¸Šå‚³ç´‹ç†åœ–ç‰‡ (PNG)</label>
                <input type="file" id="textureUpload" accept="image/png,image/jpeg" style="width: 100%; margin-bottom: 10px;">
                <button class="button" id="loadDefaultTexture" style="background: #ff6b35;">è¼‰å…¥é è¨­ç´‹ç†</button>
            </div>

            <div class="control-group">
                <label>ä¸Šå‚³3Dæ¨¡å‹ (GLB)</label>
                <input type="file" id="modelUpload" accept=".glb,.gltf" style="width: 100%; margin-bottom: 10px;">
                <button class="button" id="loadDefaultModel" style="background: #8b4513;">è¼‰å…¥é è¨­é¦¬éˆ´è–¯æ¨¡å‹</button>
                <a href="png-to-potato-glb.html" target="_blank" class="button" style="background: #ff6b35; text-decoration: none; display: inline-block; margin-top: 8px; text-align: center;">ğŸ¨ å‰µå»ºè‡ªå®šç¾©GLBæ¨¡å‹</a>
            </div>

            <div class="control-group">
                <label>é¢å…·é€æ˜åº¦: <span id="maskOpacityValue">0.9</span></label>
                <input type="range" id="maskOpacitySlider" min="0" max="1" step="0.1" value="0.9">
            </div>

            <div class="control-group">
                <label>é¢å…·ç¸®æ”¾: <span id="maskScaleValue">1.0</span></label>
                <input type="range" id="maskScaleSlider" min="0.5" max="2.0" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showMask" checked> é¡¯ç¤ºé¢å…·
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="cutoutEyes" checked> æŒ–æ´çœ¼ç›
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="cutoutMouth" checked> æŒ–æ´å˜´å·´
                </label>
            </div>

            <div class="control-group">
                <label>æŒ–æ´å¼·åº¦: <span id="cutoutStrengthValue">0.8</span></label>
                <input type="range" id="cutoutStrengthSlider" min="0.1" max="1.5" step="0.1" value="0.8">
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="use3DMask" checked> ä½¿ç”¨3Dé¢å…· (WebGL)
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="useCustomModel" checked> ä½¿ç”¨3Dæ¨¡å‹ (GLB)
                </label>
            </div>

            <div class="control-group">
                <label>3Dé¢å…·æ·±åº¦: <span id="maskDepthValue">0.1</span></label>
                <input type="range" id="maskDepthSlider" min="0.01" max="0.5" step="0.01" value="0.1">
            </div>

            <hr style="margin: 20px 0; border: 1px solid #555;">

            <button class="button" id="resetCamera">é‡ç½®ç›¸æ©Ÿ</button>
            <button class="button" id="toggleFullscreen">å…¨è¢å¹•</button>
        </div>

        <div id="fps">
            FPS: <span id="fpsValue">0</span>
        </div>
    </div>

    <script>
        class OfficialFaceMeshTracker {
            constructor() {
                this.videoElement = document.querySelector('.input_video');
                this.canvasElement = document.querySelector('.output_canvas');
                this.canvasCtx = this.canvasElement.getContext('2d');
                this.faceMesh = null;
                this.camera = null;
                this.isTracking = false;
                this.fpsCounter = 0;
                this.lastTime = 0;
                
                // é¢å…·ç›¸é—œ
                this.maskTexture = null;
                this.maskImage = null;
                this.maskCanvas = null;
                this.maskCtx = null;
                
                // 3Dé¢å…·ç›¸é—œ
                this.threeMaskMesh = null;
                this.threeMaskGeometry = null;
                this.threeMaskMaterial = null;
                this.threeMaskTexture = null;
                this.threeScene = null;
                this.threeCamera = null;
                this.threeRenderer = null;
                this.threeMaskContainer = null;
                
                // 3Dæ¨¡å‹ç›¸é—œ
                this.threeModel = null;
                this.threeModelLoader = null;
                this.useCustomModel = false;
                
                // ç‹€æ…‹è¿½è¹¤
                this.hasShownLandmarkCount = false;
                
                this.settings = {
                    opacity: 0.8,
                    meshColor: '#C0C0C0',
                    landmarkColor: '#FF3030',
                    showLandmarks: true,
                    showMesh: true,
                    // é¢å…·è¨­å®š
                    showMask: true,
                    maskOpacity: 0.9,
                    maskScale: 1.0,
                    cutoutEyes: true,
                    cutoutMouth: true,
                    cutoutStrength: 0.8,
                    // 3Dé¢å…·è¨­å®š
                    use3DMask: true,
                    maskDepth: 0.1
                };
                
                this.init();
            }

            async init() {
                try {
                    await this.setupMediaPipe();
                    this.setupCamera();
                    this.setupMask();
                    this.setupControls();
                    this.setupEventListeners();
                    this.animate();
                    this.updateStatus('å·²é€£æ¥', true);
                } catch (error) {
                    console.error('åˆå§‹åŒ–å¤±æ•—:', error);
                    this.updateStatus('åˆå§‹åŒ–å¤±æ•—: ' + error.message, false);
                }
            }

            async setupMediaPipe() {
                // æª¢æŸ¥MediaPipeæ˜¯å¦å¯ç”¨
                if (typeof FaceMesh === 'undefined') {
                    throw new Error('MediaPipe Face Mesh æœªè¼‰å…¥');
                }

                this.faceMesh = new FaceMesh({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                    }
                });

                this.faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                this.faceMesh.onResults((results) => {
                    this.onFaceMeshResults(results);
                });
            }

            async setupCamera() {
                try {
                    // è¨­å®šcanvaså°ºå¯¸
                    this.canvasElement.width = window.innerWidth;
                    this.canvasElement.height = window.innerHeight;
                    
                    // ä½¿ç”¨MediaPipeçš„Cameraé¡
                    this.camera = new Camera(this.videoElement, {
                        onFrame: async () => {
                            if (this.faceMesh) {
                                await this.faceMesh.send({ image: this.videoElement });
                            }
                        },
                        width: 1280,
                        height: 720
                    });
                    
                    this.camera.start();
                    this.isTracking = true;
                } catch (error) {
                    console.error('ç›¸æ©Ÿè¨ªå•å¤±æ•—:', error);
                    this.updateStatus('ç›¸æ©Ÿè¨ªå•å¤±æ•—: ' + error.message, false);
                }
            }

            setupMask() {
                // å‰µå»ºé¢å…·canvas
                this.maskCanvas = document.createElement('canvas');
                this.maskCtx = this.maskCanvas.getContext('2d');
                
                // è¼‰å…¥é è¨­ç´‹ç†
                this.loadDefaultTexture();
                
                // å»¶é²å‰µå»º3Dé¢å…·ï¼Œç¢ºä¿Three.jså·²è¼‰å…¥
                setTimeout(() => {
                    this.create3DMask();
                }, 100);
            }

            loadDefaultTexture() {
                // å‰µå»ºé¦¬éˆ´è–¯è‡‰ç´‹ç†
                this.maskCanvas.width = 512;
                this.maskCanvas.height = 512;
                
                // å‰µå»ºé¦¬éˆ´è–¯è‰²èƒŒæ™¯
                const gradient = this.maskCtx.createRadialGradient(256, 256, 0, 256, 256, 256);
                gradient.addColorStop(0, '#8B4513');
                gradient.addColorStop(0.3, '#A0522D');
                gradient.addColorStop(0.7, '#CD853F');
                gradient.addColorStop(1, '#DEB887');
                
                this.maskCtx.fillStyle = gradient;
                this.maskCtx.fillRect(0, 0, 512, 512);
                
                // æ·»åŠ é¦¬éˆ´è–¯è‡‰çš„ç‰¹å¾µ
                this.addPotatoFaceFeatures();
                
                this.maskImage = this.maskCanvas;
                
                // å‰µå»ºThree.jsç´‹ç†
                if (this.isThreeJSReady()) {
                    this.threeMaskTexture = new THREE.CanvasTexture(this.maskCanvas);
                    this.threeMaskTexture.needsUpdate = true;
                    
                    // æ›´æ–°3Dé¢å…·æè³ª
                    if (this.threeMaskMaterial) {
                        this.threeMaskMaterial.map = this.threeMaskTexture;
                        this.threeMaskMaterial.needsUpdate = true;
                    }
                }
                
                this.updateStatus('é¦¬éˆ´è–¯è‡‰ç´‹ç†å·²è¼‰å…¥ï¼Œ3Dé¢å…·å·²å‰µå»º', true);
            }

            addPotatoFaceFeatures() {
                // æ·»åŠ é¦¬éˆ´è–¯è‡‰çš„ç‰¹å¾µ
                
                // çœ¼ç›å€åŸŸ - æ·±è‰²
                this.maskCtx.fillStyle = '#654321';
                this.maskCtx.beginPath();
                this.maskCtx.ellipse(200, 200, 30, 20, 0, 0, 2 * Math.PI);
                this.maskCtx.fill();
                
                this.maskCtx.beginPath();
                this.maskCtx.ellipse(312, 200, 30, 20, 0, 0, 2 * Math.PI);
                this.maskCtx.fill();
                
                // é¼»å­å€åŸŸ - çªå‡º
                this.maskCtx.fillStyle = '#A0522D';
                this.maskCtx.beginPath();
                this.maskCtx.ellipse(256, 250, 15, 25, 0, 0, 2 * Math.PI);
                this.maskCtx.fill();
                
                // å˜´å·´å€åŸŸ - å¾®ç¬‘
                this.maskCtx.strokeStyle = '#654321';
                this.maskCtx.lineWidth = 8;
                this.maskCtx.beginPath();
                this.maskCtx.arc(256, 300, 40, 0, Math.PI);
                this.maskCtx.stroke();
                
                // æ·»åŠ é¦¬éˆ´è–¯çš„æ–‘é»å’Œç´‹ç†
                this.maskCtx.fillStyle = '#654321';
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * 512;
                    const y = Math.random() * 512;
                    const size = Math.random() * 8 + 2;
                    
                    this.maskCtx.beginPath();
                    this.maskCtx.arc(x, y, size, 0, 2 * Math.PI);
                    this.maskCtx.fill();
                }
                
                // æ·»åŠ é«˜å…‰æ•ˆæœ
                this.maskCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.maskCtx.beginPath();
                this.maskCtx.ellipse(200, 150, 40, 20, Math.PI / 4, 0, 2 * Math.PI);
                this.maskCtx.fill();
                
                this.maskCtx.beginPath();
                this.maskCtx.ellipse(312, 150, 40, 20, -Math.PI / 4, 0, 2 * Math.PI);
                this.maskCtx.fill();
            }

            // MediaPipe Face Mesh UVåº§æ¨™å°æ‡‰è¡¨
            getFaceMeshUVs() {
                // é€™æ˜¯MediaPipe Face Meshçš„æ¨™æº–UVåº§æ¨™
                // æ¯å€‹é ‚é»å°æ‡‰åˆ°ç´‹ç†åœ–çš„UVåº§æ¨™ (u, v)
                const uvs = [];
                
                // ç”Ÿæˆ478å€‹é ‚é»çš„UVåº§æ¨™ (æ”¯æ´æ–°ç‰ˆæœ¬MediaPipe)
                // è‡‰éƒ¨ä¸­å¿ƒç‚º(0.5, 0.5)ï¼Œé‚Šç·£ç‚º(0,0)å’Œ(1,1)
                for (let i = 0; i < 478; i++) {
                    // æ ¹æ“šé ‚é»ç´¢å¼•è¨ˆç®—UVåº§æ¨™
                    // é€™è£¡ä½¿ç”¨æ›´ç²¾ç¢ºçš„UVæ˜ å°„ï¼ŒåŸºæ–¼MediaPipeçš„æ¨™æº–ä½ˆå±€
                    let u, v;
                    
                    if (i < 10) {
                        // è‡‰éƒ¨è¼ªå»“ - åœ“å½¢åˆ†ä½ˆ
                        const angle = (i / 10) * 2 * Math.PI;
                        u = 0.5 + Math.cos(angle) * 0.4;
                        v = 0.5 + Math.sin(angle) * 0.4;
                    } else if (i < 33) {
                        // è‡‰éƒ¨è¼ªå»“å»¶ä¼¸
                        const t = (i - 10) / 23;
                        u = 0.5 + Math.cos(t * 2 * Math.PI) * (0.4 - t * 0.1);
                        v = 0.5 + Math.sin(t * 2 * Math.PI) * (0.4 - t * 0.1);
                    } else if (i < 47) {
                        // å·¦çœ¼å€åŸŸ
                        const t = (i - 33) / 14;
                        u = 0.35 + Math.cos(t * 2 * Math.PI) * 0.15;
                        v = 0.4 + Math.sin(t * 2 * Math.PI) * 0.1;
                    } else if (i < 61) {
                        // å·¦çœ¼çœ‰æ¯›
                        const t = (i - 47) / 14;
                        u = 0.35 + Math.cos(t * 2 * Math.PI) * 0.15;
                        v = 0.3 + Math.sin(t * 2 * Math.PI) * 0.1;
                    } else if (i < 75) {
                        // å³çœ¼çœ‰æ¯›
                        const t = (i - 61) / 14;
                        u = 0.65 + Math.cos(t * 2 * Math.PI) * 0.15;
                        v = 0.3 + Math.sin(t * 2 * Math.PI) * 0.1;
                    } else if (i < 89) {
                        // å³çœ¼å€åŸŸ
                        const t = (i - 75) / 14;
                        u = 0.65 + Math.cos(t * 2 * Math.PI) * 0.15;
                        v = 0.4 + Math.sin(t * 2 * Math.PI) * 0.1;
                    } else if (i < 100) {
                        // é¼»å­å€åŸŸ
                        const t = (i - 89) / 11;
                        u = 0.5 + Math.cos(t * Math.PI) * 0.1;
                        v = 0.45 + t * 0.1;
                    } else if (i < 150) {
                        // è‡‰éƒ¨ä¸»è¦å€åŸŸ - æ©¢åœ“åˆ†ä½ˆ
                        const t = (i - 100) / 50;
                        const angle = t * 2 * Math.PI;
                        u = 0.5 + Math.cos(angle) * (0.3 - t * 0.1);
                        v = 0.5 + Math.sin(angle) * (0.25 - t * 0.1);
                    } else if (i < 200) {
                        // è‡‰éƒ¨å¡«å……å€åŸŸ
                        const t = (i - 150) / 50;
                        u = 0.5 + (Math.random() - 0.5) * 0.2;
                        v = 0.5 + (Math.random() - 0.5) * 0.2;
                    } else if (i < 250) {
                        // å˜´å·´å¤–åœ
                        const t = (i - 200) / 50;
                        const angle = t * 2 * Math.PI;
                        u = 0.5 + Math.cos(angle) * 0.25;
                        v = 0.6 + Math.sin(angle) * 0.15;
                    } else if (i < 300) {
                        // å˜´å·´å…§éƒ¨
                        const t = (i - 250) / 50;
                        const angle = t * 2 * Math.PI;
                        u = 0.5 + Math.cos(angle) * 0.15;
                        v = 0.6 + Math.sin(angle) * 0.1;
                    } else if (i < 350) {
                        // è‡‰éƒ¨é‚Šç·£å¡«å……
                        const t = (i - 300) / 50;
                        u = 0.5 + (Math.random() - 0.5) * 0.3;
                        v = 0.5 + (Math.random() - 0.5) * 0.3;
                    } else if (i < 400) {
                        // è‡‰éƒ¨ç´°ç¯€å¡«å……
                        const t = (i - 350) / 50;
                        u = 0.5 + (Math.random() - 0.5) * 0.25;
                        v = 0.5 + (Math.random() - 0.5) * 0.25;
                    } else if (i < 450) {
                        // è‡‰éƒ¨ç´°ç¯€å¡«å……
                        const t = (i - 400) / 50;
                        u = 0.5 + (Math.random() - 0.5) * 0.25;
                        v = 0.5 + (Math.random() - 0.5) * 0.25;
                    } else {
                        // å‰©é¤˜é ‚é» (450-477) - å‡å‹»åˆ†ä½ˆ
                        const t = (i - 450) / 28;
                        u = 0.5 + (Math.random() - 0.5) * 0.2;
                        v = 0.5 + (Math.random() - 0.5) * 0.2;
                    }
                    
                    // ç¢ºä¿UVåº§æ¨™åœ¨[0,1]ç¯„åœå…§
                    u = Math.max(0, Math.min(1, u));
                    v = Math.max(0, Math.min(1, v));
                    
                    uvs.push(u, v);
                }
                
                return uvs;
            }

            isThreeJSReady() {
                return typeof THREE !== 'undefined' && 
                       typeof THREE.Scene !== 'undefined' && 
                       typeof THREE.BufferGeometry !== 'undefined' && 
                       typeof THREE.Mesh !== 'undefined' && 
                       typeof THREE.MeshBasicMaterial !== 'undefined' && 
                       typeof THREE.WebGLRenderer !== 'undefined';
            }

            is3DMaskReady() {
                if (this.useCustomModel) {
                    return this.threeModel && this.threeScene;
                } else {
                    return this.threeMaskMesh && 
                           this.threeMaskGeometry && 
                           this.threeMaskMaterial &&
                           this.threeMaskGeometry.attributes.position &&
                           this.threeMaskGeometry.attributes.position.array &&
                           this.threeMaskGeometry.attributes.position.array.length >= 478 * 3;
                }
            }

            loadGLBModel(file) {
                if (!this.isThreeJSReady()) {
                    console.warn('Three.js æœªå®Œå…¨è¼‰å…¥ï¼Œç„¡æ³•è¼‰å…¥GLBæ¨¡å‹');
                    return;
                }

                if (!this.threeModelLoader) {
                    // å‰µå»ºGLTFLoader
                    this.threeModelLoader = new THREE.GLTFLoader();
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const arrayBuffer = e.target.result;
                    
                    this.threeModelLoader.parse(arrayBuffer, '', (gltf) => {
                        console.log('GLBæ¨¡å‹è¼‰å…¥æˆåŠŸ:', gltf);
                        
                        // ç§»é™¤èˆŠçš„æ¨¡å‹
                        if (this.threeModel) {
                            this.threeScene.remove(this.threeModel);
                        }
                        
                        // ç²å–æ¨¡å‹
                        this.threeModel = gltf.scene;
                        
                        // èª¿æ•´æ¨¡å‹å¤§å°å’Œä½ç½®
                        this.threeModel.scale.set(0.1, 0.1, 0.1);
                        this.threeModel.position.set(0, 0, 0);
                        
                        // æ·»åŠ åˆ°å ´æ™¯
                        this.threeScene.add(this.threeModel);
                        
                        // æ¨™è¨˜ä½¿ç”¨è‡ªå®šç¾©æ¨¡å‹
                        this.useCustomModel = true;
                        
                        this.updateStatus('GLBæ¨¡å‹å·²è¼‰å…¥', true);
                    }, (error) => {
                        console.error('GLBæ¨¡å‹è¼‰å…¥å¤±æ•—:', error);
                        this.updateStatus('GLBæ¨¡å‹è¼‰å…¥å¤±æ•—: ' + error.message, false);
                    });
                };
                
                reader.readAsArrayBuffer(file);
            }

            loadDefaultPotatoModel() {
                if (!this.isThreeJSReady()) {
                    console.warn('Three.js æœªå®Œå…¨è¼‰å…¥ï¼Œç„¡æ³•è¼‰å…¥é è¨­æ¨¡å‹');
                    return;
                }

                // å‰µå»ºä¸€å€‹ç°¡å–®çš„é¦¬éˆ´è–¯å½¢ç‹€å¹¾ä½•é«”
                const potatoGeometry = new THREE.SphereGeometry(1, 8, 6);
                
                // å‰µå»ºé¦¬éˆ´è–¯æè³ª
                const potatoMaterial = new THREE.MeshLambertMaterial({
                    color: 0x8B4513,
                    transparent: true,
                    opacity: this.settings.maskOpacity
                });
                
                // å‰µå»ºé¦¬éˆ´è–¯ç¶²æ ¼
                this.threeModel = new THREE.Mesh(potatoGeometry, potatoMaterial);
                
                // èª¿æ•´å¤§å°å’Œä½ç½®
                this.threeModel.scale.set(0.8, 1.2, 0.8);
                this.threeModel.position.set(0, 0, 0);
                
                // æ·»åŠ åˆ°å ´æ™¯
                if (this.threeScene) {
                    this.threeScene.add(this.threeModel);
                }
                
                // æ¨™è¨˜ä½¿ç”¨é è¨­æ¨¡å‹
                this.useCustomModel = true;
                
                this.updateStatus('é è¨­é¦¬éˆ´è–¯æ¨¡å‹å·²è¼‰å…¥', true);
            }

            create3DMask() {
                // æª¢æŸ¥Three.jsæ˜¯å¦å®Œå…¨è¼‰å…¥
                if (!this.isThreeJSReady()) {
                    console.warn('Three.js æœªå®Œå…¨è¼‰å…¥ï¼Œ3Dé¢å…·å°‡ä¸å¯ç”¨');
                    this.updateStatus('ç­‰å¾…Three.jsè¼‰å…¥...', false);
                    // ä½¿ç”¨è¼ªè©¢æ©Ÿåˆ¶ç­‰å¾…Three.jsè¼‰å…¥
                    setTimeout(() => this.create3DMask(), 100);
                    return;
                }

                // æŒ‰ç…§ç”¨æˆ¶å»ºè­°çš„å„ªåŒ–æ–¹å¼å»ºç«‹ geometry
                this.threeMaskGeometry = new THREE.BufferGeometry();
                
                // å‰µå»ºåˆå§‹é ‚é»ä½ç½® (æ”¯æ´478å€‹é»ï¼Œå…¼å®¹æ–°ç‰ˆæœ¬MediaPipe)
                const maxVertices = 478; // æ”¯æ´æ–°ç‰ˆæœ¬çš„MediaPipe Face Mesh
                const initialVertices = new Float32Array(maxVertices * 3);
                for (let i = 0; i < maxVertices; i++) {
                    initialVertices[i * 3] = 0;     // x
                    initialVertices[i * 3 + 1] = 0; // y
                    initialVertices[i * 3 + 2] = 0; // z
                }
                
                // å‰µå»ºUVåº§æ¨™
                const uvs = new Float32Array(this.getFaceMeshUVs());
                
                // è¨­ç½®å¹¾ä½•é«”å±¬æ€§
                this.threeMaskGeometry.setAttribute('position', new THREE.BufferAttribute(initialVertices, 3));
                this.threeMaskGeometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
                
                // å‰µå»ºä¸‰è§’å½¢ç´¢å¼•
                const triangles = this.createFaceMeshTriangles();
                const indices = [];
                triangles.forEach(triangle => {
                    indices.push(...triangle);
                });
                
                this.threeMaskGeometry.setIndex(indices);
                
                // è¨ˆç®—æ³•å‘é‡
                this.threeMaskGeometry.computeVertexNormals();
                
                // è²¼æè³ª
                this.threeMaskMaterial = new THREE.MeshBasicMaterial({ 
                    map: this.threeMaskTexture, 
                    transparent: true,
                    opacity: this.settings.maskOpacity,
                    side: THREE.DoubleSide
                });
                
                // å»ºç«‹ mesh
                this.threeMaskMesh = new THREE.Mesh(this.threeMaskGeometry, this.threeMaskMaterial);
                
                // å‰µå»ºThree.jså ´æ™¯ï¼ˆå¦‚æœé‚„æ²’æœ‰çš„è©±ï¼‰
                if (!this.threeScene) {
                    this.createThreeJSScene();
                }
                
                // æ·»åŠ åˆ°Three.jså ´æ™¯
                this.threeScene.add(this.threeMaskMesh);
                
                console.log('3Dé¢å…·å‰µå»ºæˆåŠŸï¼Œé ‚é»æ•¸:', this.threeMaskGeometry.attributes.position.count);
                console.log('ä¸‰è§’å½¢æ•¸:', this.threeMaskGeometry.index ? this.threeMaskGeometry.index.count / 3 : 0);
                console.log('æ”¯æ´çš„æœ€å¤§é ‚é»æ•¸:', maxVertices);
                this.updateStatus('3Dé¢å…·å·²å‰µå»º', true);
            }

            createFaceMeshTriangles() {
                // å‰µå»ºé¢éƒ¨ç¶²æ ¼çš„ä¸‰è§’å½¢ç´¢å¼•
                // ä½¿ç”¨æ›´é«˜æ•ˆçš„ä¸‰è§’å½¢ç”Ÿæˆæ–¹å¼
                const triangles = [];
                
                // è‡‰éƒ¨ä¸»è¦å€åŸŸ - ä½¿ç”¨æ‰‡ç‹€ä¸‰è§’å½¢å¡«å……
                const faceCenter = 10; // è‡‰éƒ¨ä¸­å¿ƒé»
                const faceOutline = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109];
                
                // è‡‰éƒ¨è¼ªå»“ä¸‰è§’å½¢
                for (let i = 0; i < faceOutline.length - 1; i++) {
                    triangles.push([faceCenter, faceOutline[i], faceOutline[i + 1]]);
                }
                triangles.push([faceCenter, faceOutline[faceOutline.length - 1], faceOutline[0]]);
                
                // å·¦çœ¼å€åŸŸ
                const leftEyeCenter = 33;
                const leftEyeOutline = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246];
                for (let i = 0; i < leftEyeOutline.length - 1; i++) {
                    triangles.push([leftEyeCenter, leftEyeOutline[i], leftEyeOutline[i + 1]]);
                }
                triangles.push([leftEyeCenter, leftEyeOutline[leftEyeOutline.length - 1], leftEyeOutline[0]]);
                
                // å³çœ¼å€åŸŸ
                const rightEyeCenter = 362;
                const rightEyeOutline = [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398];
                for (let i = 0; i < rightEyeOutline.length - 1; i++) {
                    triangles.push([rightEyeCenter, rightEyeOutline[i], rightEyeOutline[i + 1]]);
                }
                triangles.push([rightEyeCenter, rightEyeOutline[rightEyeOutline.length - 1], rightEyeOutline[0]]);
                
                // é¼»å­å€åŸŸ
                const noseCenter = 1;
                const noseOutline = [1, 2, 3, 4, 5, 6, 168, 8, 9, 10, 151, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468];
                for (let i = 0; i < noseOutline.length - 1; i++) {
                    triangles.push([noseCenter, noseOutline[i], noseOutline[i + 1]]);
                }
                triangles.push([noseCenter, noseOutline[noseOutline.length - 1], noseOutline[0]]);
                
                // å˜´å·´å€åŸŸ
                const mouthCenter = 13;
                const mouthOutline = [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468];
                for (let i = 0; i < mouthOutline.length - 1; i++) {
                    triangles.push([mouthCenter, mouthOutline[i], mouthOutline[i + 1]]);
                }
                triangles.push([mouthCenter, mouthOutline[mouthOutline.length - 1], mouthOutline[0]]);
                
                console.log('å‰µå»ºä¸‰è§’å½¢ç´¢å¼•ï¼Œç¸½æ•¸:', triangles.length);
                console.log('è‡‰éƒ¨è¼ªå»“ä¸‰è§’å½¢:', faceOutline.length - 1);
                console.log('å·¦çœ¼ä¸‰è§’å½¢:', leftEyeOutline.length - 1);
                console.log('å³çœ¼ä¸‰è§’å½¢:', rightEyeOutline.length - 1);
                console.log('é¼»å­ä¸‰è§’å½¢:', noseOutline.length - 1);
                console.log('å˜´å·´ä¸‰è§’å½¢:', mouthOutline.length - 1);
                
                return triangles;
            }

            createThreeJSScene() {
                if (!this.isThreeJSReady()) {
                    console.warn('Three.js æœªå®Œå…¨è¼‰å…¥ï¼Œç„¡æ³•å‰µå»º3Då ´æ™¯');
                    return;
                }

                // å‰µå»ºå ´æ™¯
                this.threeScene = new THREE.Scene();
                
                // å‰µå»ºç›¸æ©Ÿ
                this.threeCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.threeCamera.position.z = 5;
                
                // å‰µå»ºæ¸²æŸ“å™¨
                this.threeRenderer = new THREE.WebGLRenderer({ 
                    alpha: true, 
                    antialias: true,
                    preserveDrawingBuffer: true
                });
                this.threeRenderer.setSize(window.innerWidth, window.innerHeight);
                this.threeRenderer.setClearColor(0x000000, 0);
                
                // å‰µå»º3Dé¢å…·å®¹å™¨
                this.threeMaskContainer = document.createElement('div');
                this.threeMaskContainer.style.position = 'absolute';
                this.threeMaskContainer.style.top = '0';
                this.threeMaskContainer.style.left = '0';
                this.threeMaskContainer.style.width = '100%';
                this.threeMaskContainer.style.height = '100%';
                this.threeMaskContainer.style.zIndex = '3';
                this.threeMaskContainer.style.pointerEvents = 'none';
                
                // å°‡æ¸²æŸ“å™¨æ·»åŠ åˆ°å®¹å™¨
                this.threeMaskContainer.appendChild(this.threeRenderer.domElement);
                
                // æ·»åŠ åˆ°ä¸»å®¹å™¨
                const container = document.getElementById('container');
                if (container) {
                    container.appendChild(this.threeMaskContainer);
                }
                
                // æ·»åŠ å…‰æº
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.threeScene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(0, 1, 1);
                this.threeScene.add(directionalLight);
                
                // é–‹å§‹æ¸²æŸ“å¾ªç’°
                this.animateThreeJS();
                
                // æ·»åŠ çª—å£å¤§å°èª¿æ•´ç›£è½å™¨
                window.addEventListener('resize', () => {
                    if (this.threeCamera && this.threeRenderer) {
                        this.threeCamera.aspect = window.innerWidth / window.innerHeight;
                        this.threeCamera.updateProjectionMatrix();
                        this.threeRenderer.setSize(window.innerWidth, window.innerHeight);
                    }
                });
            }

            animateThreeJS() {
                if (!this.threeScene || !this.threeRenderer || !this.threeCamera) return;
                
                // æ¸²æŸ“å ´æ™¯
                this.threeRenderer.render(this.threeScene, this.threeCamera);
                
                // ç¹¼çºŒå‹•ç•«å¾ªç’°
                requestAnimationFrame(() => this.animateThreeJS());
            }

            update3DMask(landmarks) {
                if (!this.is3DMaskReady() || !this.settings.use3DMask || !landmarks || landmarks.length === 0) {
                    return;
                }
                
                try {
                    if (this.useCustomModel && this.threeModel) {
                        // æ›´æ–°3Dæ¨¡å‹ä½ç½®å’Œæ—‹è½‰
                        this.update3DModel(landmarks);
                    } else {
                        // æ›´æ–°å¹¾ä½•é«”é ‚é»
                        this.updateGeometryVertices(landmarks);
                    }
                } catch (error) {
                    console.error('æ›´æ–°3Dé¢å…·æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    throw error; // é‡æ–°æ‹‹å‡ºéŒ¯èª¤ï¼Œè®“èª¿ç”¨è€…è™•ç†
                }
            }

            update3DModel(landmarks) {
                if (!this.threeModel || landmarks.length === 0) return;
                
                // è¨ˆç®—é¢éƒ¨ä¸­å¿ƒé»
                const centerX = landmarks.reduce((sum, p) => sum + p.x, 0) / landmarks.length;
                const centerY = landmarks.reduce((sum, p) => sum + p.y, 0) / landmarks.length;
                const centerZ = landmarks.reduce((sum, p) => sum + p.z, 0) / landmarks.length;
                
                // è¨ˆç®—é¢éƒ¨å¤§å°
                const faceWidth = Math.max(...landmarks.map(p => p.x)) - Math.min(...landmarks.map(p => p.x));
                const faceHeight = Math.max(...landmarks.map(p => p.y)) - Math.min(...landmarks.map(p => p.y));
                const faceSize = Math.max(faceWidth, faceHeight);
                
                // æ›´æ–°æ¨¡å‹ä½ç½®
                this.threeModel.position.x = (centerX - 0.5) * 10;
                this.threeModel.position.y = (0.5 - centerY) * 10;
                this.threeModel.position.z = centerZ * 5 + this.settings.maskDepth;
                
                // æ ¹æ“šé¢éƒ¨å¤§å°èª¿æ•´æ¨¡å‹ç¸®æ”¾
                const scale = faceSize * 20 * this.settings.maskScale;
                this.threeModel.scale.set(scale, scale, scale);
                
                // æ ¹æ“šé¢éƒ¨å‚¾æ–œèª¿æ•´æ¨¡å‹æ—‹è½‰
                const leftEye = landmarks[33]; // å·¦çœ¼ä¸­å¿ƒ
                const rightEye = landmarks[362]; // å³çœ¼ä¸­å¿ƒ
                if (leftEye && rightEye) {
                    const eyeAngle = Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x);
                    this.threeModel.rotation.z = eyeAngle;
                }
            }

            updateGeometryVertices(landmarks) {
                // æª¢æŸ¥é ‚é»æ•¸é‡æ˜¯å¦åŒ¹é… (æ”¯æ´468å’Œ478)
                if (landmarks.length !== 468 && landmarks.length !== 478) {
                    console.warn('Landmarksæ•¸é‡ä¸åŒ¹é…ï¼ŒæœŸæœ›468æˆ–478ï¼Œå¯¦éš›:', landmarks.length);
                    return;
                }
                
                // ç²å–ç¾æœ‰çš„é ‚é»é™£åˆ—
                const positions = this.threeMaskGeometry.attributes.position;
                
                // é€å€‹æ›´æ–°é ‚é»ä½ç½®ï¼Œé¿å…è¶…å‡ºç·©è¡å€
                for (let i = 0; i < landmarks.length && i < 478; i++) {
                    const landmark = landmarks[i];
                    if (landmark && i * 3 + 2 < positions.array.length) {
                        positions.array[i * 3] = (landmark.x - 0.5) * 10;      // xåº§æ¨™è½‰æ›
                        positions.array[i * 3 + 1] = (0.5 - landmark.y) * 10;  // yåº§æ¨™è½‰æ›
                        positions.array[i * 3 + 2] = landmark.z * 5 + this.settings.maskDepth;  // zåº§æ¨™è½‰æ›
                    }
                }
                
                // æ¨™è¨˜é ‚é»é™£åˆ—éœ€è¦æ›´æ–°
                positions.needsUpdate = true;
                
                // é‡æ–°è¨ˆç®—æ³•å‘é‡
                this.threeMaskGeometry.computeVertexNormals();
            }

            loadCustomTexture(file) {
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // å‰µå»ºæ–°çš„canvasä¾†è™•ç†ç´‹ç†
                        this.maskCanvas.width = img.width;
                        this.maskCanvas.height = img.height;
                        this.maskCtx.clearRect(0, 0, img.width, img.height);
                        this.maskCtx.drawImage(img, 0, 0);
                        
                        this.maskImage = this.maskCanvas;
                        
                        // å‰µå»ºThree.jsç´‹ç†
                        if (this.isThreeJSReady()) {
                            this.threeMaskTexture = new THREE.CanvasTexture(this.maskCanvas);
                            this.threeMaskTexture.needsUpdate = true;
                            
                            // æ›´æ–°3Dé¢å…·æè³ª
                            if (this.threeMaskMaterial) {
                                this.threeMaskMaterial.map = this.threeMaskTexture;
                                this.threeMaskMaterial.needsUpdate = true;
                            }
                        }
                        
                        this.updateStatus('è‡ªå®šç¾©ç´‹ç†å·²è¼‰å…¥', true);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            drawMask(landmarks) {
                if (!this.settings.showMask || !this.maskImage) return;
                
                const canvas = this.canvasElement;
                const ctx = this.canvasCtx;
                
                ctx.save();
                ctx.globalAlpha = this.settings.maskOpacity;
                
                // è¨ˆç®—é¢éƒ¨é‚Šç•Œæ¡†
                const bounds = this.getFaceBounds(landmarks);
                const faceWidth = bounds.width * this.settings.maskScale;
                const faceHeight = bounds.height * this.settings.maskScale;
                const faceX = bounds.x - (faceWidth - bounds.width) / 2;
                const faceY = bounds.y - (faceHeight - bounds.height) / 2;
                
                // ç¹ªè£½é¢å…·
                ctx.drawImage(this.maskImage, faceX, faceY, faceWidth, faceHeight);
                
                // æ‡‰ç”¨æŒ–æ´æ•ˆæœ
                if (this.settings.cutoutEyes) {
                    this.applyEyeCutout(ctx, landmarks);
                }
                
                if (this.settings.cutoutMouth) {
                    this.applyMouthCutout(ctx, landmarks);
                }
                
                ctx.restore();
            }

            getFaceBounds(landmarks) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                
                // è‡‰éƒ¨è¼ªå»“é»
                const faceOutline = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109];
                
                faceOutline.forEach(index => {
                    if (landmarks[index]) {
                        const x = landmarks[index].x * this.canvasElement.width;
                        const y = landmarks[index].y * this.canvasElement.height;
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                });
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }

            applyEyeCutout(ctx, landmarks) {
                // å·¦çœ¼æŒ–æ´
                this.applyCutout(ctx, landmarks, [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246]);
                
                // å³çœ¼æŒ–æ´
                this.applyCutout(ctx, landmarks, [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398]);
            }

            applyMouthCutout(ctx, landmarks) {
                // å˜´å·´æŒ–æ´
                this.applyCutout(ctx, landmarks, [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468]);
            }

            applyCutout(ctx, landmarks, indices) {
                if (indices.length < 3) return;
                
                const canvas = this.canvasElement;
                const points = indices.map(index => {
                    if (landmarks[index]) {
                        return {
                            x: landmarks[index].x * canvas.width,
                            y: landmarks[index].y * canvas.height
                        };
                    }
                    return null;
                }).filter(p => p !== null);
                
                if (points.length < 3) return;
                
                // å‰µå»ºæŒ–æ´è·¯å¾‘
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                
                ctx.closePath();
                
                // ä½¿ç”¨åˆæˆæ¨¡å¼å‰µå»ºæŒ–æ´æ•ˆæœ
                ctx.globalCompositeOperation = 'destination-out';
                ctx.fillStyle = `rgba(0, 0, 0, ${this.settings.cutoutStrength})`;
                ctx.fill();
                
                // æ¢å¾©åˆæˆæ¨¡å¼
                ctx.globalCompositeOperation = 'source-over';
            }

            setupControls() {
                // é€æ˜åº¦æ§åˆ¶
                const opacitySlider = document.getElementById('opacitySlider');
                const opacityValue = document.getElementById('opacityValue');
                
                opacitySlider.addEventListener('input', (e) => {
                    this.settings.opacity = parseFloat(e.target.value);
                    opacityValue.textContent = this.settings.opacity.toFixed(1);
                });

                // ç¶²æ ¼é¡è‰²æ§åˆ¶
                const meshColor = document.getElementById('meshColor');
                meshColor.addEventListener('change', (e) => {
                    this.settings.meshColor = e.target.value;
                });

                // ç‰¹å¾µé»é¡è‰²æ§åˆ¶
                const landmarkColor = document.getElementById('landmarkColor');
                landmarkColor.addEventListener('change', (e) => {
                    this.settings.landmarkColor = e.target.value;
                });

                // é¡¯ç¤ºé¸é …
                document.getElementById('showLandmarks').addEventListener('change', (e) => {
                    this.settings.showLandmarks = e.target.checked;
                });

                document.getElementById('showMesh').addEventListener('change', (e) => {
                    this.settings.showMesh = e.target.checked;
                });

                // é¢å…·æ§åˆ¶
                document.getElementById('showMask').addEventListener('change', (e) => {
                    this.settings.showMask = e.target.checked;
                });

                document.getElementById('cutoutEyes').addEventListener('change', (e) => {
                    this.settings.cutoutEyes = e.target.checked;
                });

                document.getElementById('cutoutMouth').addEventListener('change', (e) => {
                    this.settings.cutoutMouth = e.target.checked;
                });

                // é¢å…·é€æ˜åº¦æ§åˆ¶
                const maskOpacitySlider = document.getElementById('maskOpacitySlider');
                const maskOpacityValue = document.getElementById('maskOpacityValue');
                
                maskOpacitySlider.addEventListener('input', (e) => {
                    this.settings.maskOpacity = parseFloat(e.target.value);
                    maskOpacityValue.textContent = this.settings.maskOpacity.toFixed(1);
                });

                // é¢å…·ç¸®æ”¾æ§åˆ¶
                const maskScaleSlider = document.getElementById('maskScaleSlider');
                const maskScaleValue = document.getElementById('maskScaleValue');
                
                maskScaleSlider.addEventListener('input', (e) => {
                    this.settings.maskScale = parseFloat(e.target.value);
                    maskScaleValue.textContent = this.settings.maskScale.toFixed(1);
                });

                // æŒ–æ´å¼·åº¦æ§åˆ¶
                const cutoutStrengthSlider = document.getElementById('cutoutStrengthSlider');
                const cutoutStrengthValue = document.getElementById('cutoutStrengthValue');
                
                cutoutStrengthSlider.addEventListener('input', (e) => {
                    this.settings.cutoutStrength = parseFloat(e.target.value);
                    cutoutStrengthValue.textContent = this.settings.cutoutStrength.toFixed(1);
                });

                // 3Dé¢å…·æ§åˆ¶
                document.getElementById('use3DMask').addEventListener('change', (e) => {
                    this.settings.use3DMask = e.target.checked;
                });

                // 3Dæ¨¡å‹æ§åˆ¶
                document.getElementById('useCustomModel').addEventListener('change', (e) => {
                    this.settings.useCustomModel = e.target.checked;
                    this.useCustomModel = e.target.checked;
                });

                // 3Dé¢å…·æ·±åº¦æ§åˆ¶
                const maskDepthSlider = document.getElementById('maskDepthSlider');
                const maskDepthValue = document.getElementById('maskDepthValue');
                
                maskDepthSlider.addEventListener('input', (e) => {
                    this.settings.maskDepth = parseFloat(e.target.value);
                    maskDepthValue.textContent = this.settings.maskDepth.toFixed(2);
                });

                // ç´‹ç†ä¸Šå‚³
                document.getElementById('textureUpload').addEventListener('change', (e) => {
                    this.loadCustomTexture(e.target.files[0]);
                });

                // è¼‰å…¥é è¨­ç´‹ç†
                document.getElementById('loadDefaultTexture').addEventListener('click', () => {
                    this.loadDefaultTexture();
                });

                // è¼‰å…¥GLBæ¨¡å‹
                document.getElementById('modelUpload').addEventListener('change', (e) => {
                    this.loadGLBModel(e.target.files[0]);
                });

                // è¼‰å…¥é è¨­é¦¬éˆ´è–¯æ¨¡å‹
                document.getElementById('loadDefaultModel').addEventListener('click', () => {
                    this.loadDefaultPotatoModel();
                });

                // é‡ç½®ç›¸æ©Ÿ
                document.getElementById('resetCamera').addEventListener('click', () => {
                    this.resetCamera();
                });

                // å…¨è¢å¹•
                document.getElementById('toggleFullscreen').addEventListener('click', () => {
                    this.toggleFullscreen();
                });
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.onWindowResize();
                });

                // éš±è—æ§åˆ¶é¢æ¿çš„å¿«æ·éµ
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'h' || e.key === 'H') {
                        this.toggleControls();
                    }
                });
            }

            onFaceMeshResults(results) {
                this.canvasCtx.save();
                this.canvasCtx.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
                
                // ç¹ªè£½åŸå§‹è¦–è¨Š
                this.canvasCtx.drawImage(results.image, 0, 0, this.canvasElement.width, this.canvasElement.height);
                
                if (results.multiFaceLandmarks) {
                    for (const landmarks of results.multiFaceLandmarks) {
                        // é¡¯ç¤ºlandmarksæ•¸é‡ä¿¡æ¯ï¼ˆåƒ…åœ¨ç¬¬ä¸€æ¬¡æª¢æ¸¬åˆ°æ™‚ï¼‰
                        if (!this.hasShownLandmarkCount) {
                            console.log('æª¢æ¸¬åˆ°MediaPipe Face Meshç‰ˆæœ¬ï¼Œlandmarksæ•¸é‡:', landmarks.length);
                            this.hasShownLandmarkCount = true;
                        }
                        
                        // å˜—è©¦æ›´æ–°3Dé¢å…·ï¼Œå¦‚æœå¤±æ•—å‰‡å›é€€åˆ°2Dæ¨¡å¼
                        if (this.settings.use3DMask && (this.threeMaskMesh || this.threeModel)) {
                            try {
                                this.update3DMask(landmarks);
                            } catch (error) {
                                console.warn('3Dé¢å…·æ›´æ–°å¤±æ•—ï¼Œå›é€€åˆ°2Dæ¨¡å¼:', error);
                                this.settings.use3DMask = false;
                                // æ›´æ–°UIç‹€æ…‹
                                const use3DMaskCheckbox = document.getElementById('use3DMask');
                                if (use3DMaskCheckbox) {
                                    use3DMaskCheckbox.checked = false;
                                }
                                // ç¹ªè£½2Dé¢å…·
                                this.drawMask(landmarks);
                            }
                        } else {
                            // ç¹ªè£½2Dé¢å…·ï¼ˆåœ¨ç¶²æ ¼å’Œç‰¹å¾µé»ä¸‹æ–¹ï¼‰
                            this.drawMask(landmarks);
                        }
                        
                        if (this.settings.showMesh) {
                            // ç¹ªè£½ç¶²æ ¼
                            this.drawConnectors(this.canvasCtx, landmarks, FACEMESH_TESSELATION, {
                                color: this.settings.meshColor + Math.floor(this.settings.opacity * 255).toString(16).padStart(2, '0')
                            });
                        }
                        
                        if (this.settings.showLandmarks) {
                            // ç¹ªè£½ç‰¹å¾µé»
                            this.drawLandmarks(this.canvasCtx, landmarks, {
                                color: this.settings.landmarkColor,
                                lineWidth: 1
                            });
                        }
                    }
                }
                
                this.canvasCtx.restore();
            }

            drawConnectors(ctx, landmarks, connections, style) {
                const canvas = this.canvasElement;
                
                ctx.strokeStyle = style.color;
                ctx.lineWidth = style.lineWidth || 1;
                
                connections.forEach(([start, end]) => {
                    if (landmarks[start] && landmarks[end]) {
                        const startX = landmarks[start].x * canvas.width;
                        const startY = landmarks[start].y * canvas.height;
                        const endX = landmarks[end].x * canvas.width;
                        const endY = landmarks[end].y * canvas.height;
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                    }
                });
            }

            drawLandmarks(ctx, landmarks, style) {
                const canvas = this.canvasElement;
                
                ctx.fillStyle = style.color;
                ctx.lineWidth = style.lineWidth || 1;
                
                landmarks.forEach(landmark => {
                    const x = landmark.x * canvas.width;
                    const y = landmark.y * canvas.height;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }

            resetCamera() {
                if (this.camera) {
                    this.camera.stop();
                    this.setupCamera();
                }
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }

            toggleControls() {
                const controls = document.getElementById('controls');
                controls.style.display = controls.style.display === 'none' ? 'block' : 'none';
            }

            onWindowResize() {
                this.canvasElement.width = window.innerWidth;
                this.canvasElement.height = window.innerHeight;
            }

            updateStatus(text, isConnected) {
                const statusText = document.getElementById('statusText');
                statusText.textContent = text;
                statusText.style.color = isConnected ? '#4CAF50' : '#f44336';
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // æ›´æ–°FPSè¨ˆæ•¸å™¨
                this.fpsCounter++;
                const currentTime = performance.now();
                
                if (currentTime - this.lastTime >= 1000) {
                    document.getElementById('fpsValue').textContent = this.fpsCounter;
                    this.fpsCounter = 0;
                    this.lastTime = currentTime;
                }
            }
        }

        // ç•¶é é¢åŠ è¼‰å®Œæˆå¾Œåˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            // ç­‰å¾…MediaPipeè¼‰å…¥
            let retryCount = 0;
            const maxRetries = 20;
            
            function checkMediaPipe() {
                if (retryCount >= maxRetries) {
                    console.error('MediaPipe è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£æ¥');
                    document.getElementById('statusText').textContent = 'MediaPipe è¼‰å…¥å¤±æ•—';
                    return;
                }
                
                if (typeof FaceMesh !== 'undefined' && typeof Camera !== 'undefined') {
                    console.log('MediaPipe å·²è¼‰å…¥ï¼Œé–‹å§‹åˆå§‹åŒ–...');
                    new OfficialFaceMeshTracker();
                } else {
                    retryCount++;
                    console.log(`ç­‰å¾… MediaPipe è¼‰å…¥... (å˜—è©¦ ${retryCount}/${maxRetries})`);
                    setTimeout(checkMediaPipe, 500);
                }
            }
            
            checkMediaPipe();
        });
    </script>
</body>
</html>
